#+TITLE: Literate Emacs configuration
#+AUTHOR: Timm Lichte
#+FILETAGS: emacs
#+STARTUP: indent
#+STARTUP: hideblocks content
#+TODO: TODO | DONE CANCELED

http://emacs-bootstrap.com/

* General appearence

** Toolbar

Don't show toolbar:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
#+END_SRC

** Signals

No beep:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

** Syntax highlighting

Brackets:
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Apply syntax highlighting to all buffers:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

*** highlight-symbol

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :config
  (setq highlight-symbol-idle-delay 0.2)
  (add-hook 'highlight-symbol-mode-hook
            (function
             (lambda () (highlight-symbol-nav-mode +1)))))
#+END_SRC

** Lines

Highlight line of cursor:
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Soft-wrap lines:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Line numbers:
#+BEGIN_SRC emacs-lisp
;; (global-linum-mode t)
;; (setq linum-format " %3d ")
#+END_SRC

** Cursor

Cursor blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 1)										; blink
(setq blink-cursor-blinks 0)						; blink forever
#+END_SRC

** Theme

Theme:
#+BEGIN_SRC emacs-lisp
(setq themes-dir
      (expand-file-name "themes" user-emacs-directory))
(add-to-list 'custom-theme-load-path themes-dir)
(load-theme 'monokai t)
#+END_SRC

** Mode line and window labels

Mode line:
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
	:ensure t
	:init
	;; (setq sml/theme 'dark)
	(setq sml/no-confirm-load-theme t)
	:config
	(sml/setup)
	)
#+END_SRC

Show file path in window title:
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '(buffer-file-name "%b - %f" ; File buffer
        (dired-directory dired-directory ; Dired buffer
         (revert-buffer-function "%b" ; Buffer Menu
																 ("%b - Dir: " default-directory))))) ; Plain buffer
#+END_SRC

Show date and time:
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(display-time-mode +1)
#+END_SRC

Fringe style:
#+BEGIN_SRC emacs-lisp
;; (set-face-attribute 'fringe nil :background "#3F3F3F" :foreground "#3F3F3F")
#+END_SRC

** Distraction-free mode

Distraction-free mode:
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
	:ensure t
	:bind
	(:map writeroom-mode-map
				("C-M-<" . writeroom-decrease-width)
				("C-M->" . writeroom-increase-width)
				("C-M-=" . writeroom-adjust-width)
				("C-<f10>" . writeroom-toggle-mode-line)
				)
	)
(global-set-key (kbd "<f10>") 'writeroom-mode)
#+END_SRC

** Font 

Toggle proportional mode when appropriate.
Inspired by https://ogbe.net/blog/toggle-serif.html
#+BEGIN_SRC emacs-lisp
(defvar font-preserve-default-list nil
  "A list holding the faces that preserve the default family and
  height when TOGGLE-SERIF is used.")
(setq font-preserve-default-list
      '(;; LaTeX markup
        font-latex-math-face
        font-latex-sedate-face
        font-latex-warning-face
        ;; org markup
        org-latex-and-related
        org-meta-line
        org-verbatim
        org-block-begin-line
        ;; syntax highlighting using font-lock
        font-lock-builtin-face
        font-lock-comment-delimiter-face
        font-lock-comment-face
        font-lock-constant-face
        font-lock-doc-face
        font-lock-function-name-face
        font-lock-keyword-face
        font-lock-negation-char-face
        font-lock-preprocessor-face
        font-lock-regexp-grouping-backslash
        font-lock-regexp-grouping-construct
        font-lock-string-face
        font-lock-type-face
        font-lock-variable-name-face
        font-lock-warning-face))
(defun toggle-proportional ()
  "Change the default face of the current buffer to use a proportional family."
  (interactive)
  (when (display-graphic-p)  ;; this is only for graphical emacs
    ;; the serif font familiy and height, save the default attributes
    (let ((proportional-fam "Segoe UI")
          (proportional-height 125)
          (default-fam (face-attribute 'default :family))
          (default-height (face-attribute 'default :height)))
      (if (not (bound-and-true-p default-cookie))
          (progn (make-local-variable 'default-cookie)
                 (make-local-variable 'preserve-default-cookies-list)
                 (setq preserve-default-cookies-list nil)
                 ;; remap default face to serif
                 (setq default-cookie
                       (face-remap-add-relative
                        'default :family proportional-fam :height proportional-height))
                 ;; keep previously defined monospace fonts the same
                 (dolist (face font-preserve-default-list)
                   (add-to-list 'preserve-default-cookies-list
                                (face-remap-add-relative
                                 face :family default-fam :height default-height)))
                 (message "Turned on proportional font."))
        ;; undo changes
        (progn (face-remap-remove-relative default-cookie)
               (dolist (cookie preserve-default-cookies-list)
                 (face-remap-remove-relative cookie))
               (setq default-cookie nil)
               (setq preserve-default-cookies-list nil)
               (message "Restored default fonts."))))))
#+END_SRC

** Overlays

#+BEGIN_SRC emacs-lisp
(use-package ov
  :ensure t)
#+END_SRC

* Minibuffer

Shorten yes/no answers to y/n:
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** ido, ivy, imenu

*** ido

#+BEGIN_SRC emacs-lisp
;; ;; ido improves buffer switching experience
;; (ido-mode 1)
;; (ido-everywhere 1)
;; ;; add vertical mode to ido
;; (use-package ido-vertical-mode	
;; 	:ensure t
;; 	:config (ido-vertical-mode 1)	)
;; ;; add grid mode
;; (use-package ido-grid-mode
;; 	:ensure t
;; 	:config (ido-grid-mode 1))												
;; ;; add flx to ido 
;; (use-package flx-ido
;; 	:ensure t
;; 	:config 
;; 	(flx-ido-mode 1)
;; 	;; disable ido faces to see flx highlights.
;; 	(setq ido-enable-flex-matching t)
;; 	(setq ido-use-faces nil))
#+END_SRC

*** Recent files

#+BEGIN_SRC emacs-lisp
;; ;; recent files
;; (require 'recentf)
;; (recentf-mode 1)
;; ; 50 files ought to be enough.
;; (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
;; (setq recentf-max-saved-items 50)
;; (defun ido-recentf-open ()
;; 	"Use `ido-completing-read' to \\[find-file] a recent file"
;; 	(interactive)
;; 	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
;; 			(message "Opening file...")
;; 		(message "Aborting")))

#+END_SRC

*** ivy, counsel, swiper

#+BEGIN_SRC emacs-lisp
;; ;; counsel adds fuzzy search to command completion 
;; (use-package counsel
;; 	:ensure t
;; 	:config
;; 	(setq ivy-display-style 'fancy)
;; 	(setq ivy-re-builders-alist ; use flx
;; 				'((t . ivy--regex-fuzzy)))
;; 	(setq ivy-initial-inputs-alist nil) ; omit ^
;; 	(setq ivy-wrap t) ;; cycle through results
;; 	:bind
;; 	("M-x" . counsel-M-x)
;; 	("C-ß" . ivy-imenu-anywhere) ; ivy + imenu
;; 	)
;; ;; swiper
;; (use-package swiper
;; 	:ensure t
;; 	:config
;; 	;; use swiper for buffer search
;; 	(add-hook 'prog-mode-hook
;; 						(lambda ()
;; 							(local-set-key (kbd "C-s") 'swiper)))
;; 	;; (global-set-key (kbd "C-s") 'swiper) ; not good in text-mode
;; 	)
#+END_SRC

*** imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
	:ensure t)
(use-package imenu-list
	:ensure t
	:bind
	("C-?" . imenu-list)
	:init
	(setq imenu-list-focus-after-activation t)
	;; (setq imenu-list-auto-resize t)
	(setq imenu-list-position (quote left))
	(setq imenu-list-size 30)
	:config
	(add-hook 'text-mode-hook 'imenu-list-minor-mode)
	(add-hook 'prog-mode-hook 'imenu-list-minor-mode)
	)
(add-hook 'imenu-list-minor-mode-hook (lambda () (toggle-truncate-lines))) ; FIXME
(setq org-imenu-depth 4)
#+END_SRC

*** smex

Smex helps to remember often used commands; used by ido and counsel
#+BEGIN_SRC emacs-lisp
;; (use-package smex
;; 	:ensure t)
#+END_SRC

** helm

#+BEGIN_SRC emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 100)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01		; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t		 ; do not display invisible candidates
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t
					helm-mode-fuzzy-match t 			; global fuzzy match
					helm-buffers-fuzzy-matching t
					helm-recentf-fuzzy-match t
					helm-M-x-fuzzy-match t
					helm-imenu-fuzzy-match t
					helm-completion-in-region-fuzzy-match t
					helm-apropos-fuzzy-match t
					helm-autoresize-mode 1 				; re-size the completion window based on number of candidates
					helm-adaptive-mode t					; show commonly used commands first
					)
		(setq bibtex-completion-bibliography user-bibliography-file
					bibtex-completion-library-path user-bibliography-pdf-dir ; directory of PDFs
					;; bibtex-completion-notes-path "~/bibliography/helm-bibtex-notes"
					)
    (helm-mode)

		;; ;; http://emacs.stackexchange.com/a/7896/12336
		;; ;; <return> opens directory in helm-find-files, not dired
		;; (defun fu/helm-find-files-navigate-forward (orig-fun &rest args)
		;; 	(if (file-directory-p (helm-get-selection))
		;; 			(apply orig-fun args)
		;; 		(helm-maybe-exit-minibuffer)))
		;; (advice-add 'helm-execute-persistent-action :around #'fu/helm-find-files-navigate-forward)
		;; (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
		
    ;; http://emacs.stackexchange.com/a/7896/12336
		;; <backspace> before backslash lets helm-find-files  move one directory up
		(defun fu/helm-find-files-navigate-back (orig-fun &rest args)
			(if (= (length helm-pattern) (length (helm-find-files-initial-input)))
					(helm-find-files-up-one-level 1)
				(apply orig-fun args)))
		(advice-add 'helm-ff-delete-char-backward :around #'fu/helm-find-files-navigate-back)

		;; https://redd.it/3f55nm
		;; remove . and .. from helm-find-files
		(advice-add 'helm-ff-filter-candidate-one-by-one
								:around (lambda (fcn file)
													(unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
														(funcall fcn file))))
		)
  :bind (("M-y" . helm-mini)
				 ("C-x C-r" . helm-recentf)
         ("C-h a" . helm-apropos)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
				 ("C-x C-f" . helm-find-files)
         ("C-x C-y" . helm-show-kill-ring)
         ("C-x y" . helm-show-kill-ring)
         ("C-x SPC" . helm-all-mark-rings)
         ("C-x C-SPC" . helm-all-mark-rings)				 
         ("M-x" . helm-M-x)
         ("C-s" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ("C-x c y" . helm-yas-complete)
         ("C-x c Y" . helm-yas-create-snippet-on-region)
         ("C-x c SPC" . helm-all-mark-rings)
				 ("C-ß" . helm-imenu)
				 ("C-S-?" . helm-imenu-anywhere)
				 )
	:config
	(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; complete with <tab> (default is <ret>)
	(define-key helm-map (kbd "C-z") 'helm-select-action) ; show actions (default is <tab>)
	(define-key helm-map (kbd "<left>") 'backward-char) ; instead of C-f
	(define-key helm-map (kbd "<right>") 'forward-char) ; instead of C-b
)
(ido-mode -1)														; turn off ido mode, just in case

;; helm-flx: improves fuzzy matching
(use-package helm-flx
	:ensure t
	:after helm
	:config
	(helm-flx-mode +1))
;; helm-fuzzier: improves fuzzy matching even more by taking more candidates into account
(use-package helm-fuzzier
	:ensure t
	:after helm
	:config
	(helm-fuzzier-mode +1))

;; list active key bindings 
(use-package helm-descbinds
	:ensure t
  :bind ("C-h b" . helm-descbinds))
#+end_src

*** helm-swoop

#+begin_src emacs-lisp
(use-package helm-swoop
	:ensure t
	:config
	;; Move up and down like isearch
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

	;; From helm-swoop to helm-multi-swoop-all
	(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

	;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
	(define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	
	;; If nil, you can slightly boost invoke speed in exchange for text color
	(setq helm-swoop-speed-or-color t)
	
	;; Optional face for line numbers
	;; Face name is `helm-swoop-line-number-face`
	(setq helm-swoop-use-line-number-face t)

	;; If you prefer fuzzy matching (seems to be already activated)
	;; (setq helm-swoop-use-fuzzy-match t)

	;; Do not call helm-swoop with symbol or word at point
	(setq helm-swoop-pre-input-function
				(lambda () nil))

  :bind ("C-c /" . helm-swoop))
#+END_SRC

*** helm-dash

=helm-dash= depends on =sqlite3= which you probably have to install manually:
http://sqlite.org/download.html

#+BEGIN_SRC emacs-lisp
	(use-package helm-dash
		:ensure t
		:init
		(setq helm-dash-common-docsets			; active in all buffers
					'())
		(setq helm-dash-browser-func 'eww)		; use internal web browser
		(setq helm-dash-docsets-path (expand-file-name (concat wemacs-dir "/docsets"))) ; FIXME: under windows, helm-dash does not install docsets here but in ~/AppData/... Because of missing tar command?
		(add-hook 'latex-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
		(add-hook 'emacs-lisp-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Emacs Lisp"))))
		(add-hook 'org-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Org_Mode"))))
		(add-hook 'plantuml-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("PlantUML"))))
		(add-hook 'sh-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Bash"))))
		(add-hook 'python-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Python 3" "SciPy" "NumPy"))))
		:bind
		(("C-h d" . helm-dash))
		)
#+END_SRC

*** COMMENT helm-tramp

Does not work under windows so far. Therefore I commented this out:

#+BEGIN_SRC emacs-lisp
(use-package helm-tramp
	:ensure t)
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
(use-package which-key
	:ensure t
	:config
	(which-key-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; M-x in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-x") 'abort-recursive-edit)))

;; M-y in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-y") 'abort-recursive-edit)))

;; C-ß in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-ß") 'abort-recursive-edit)))

;; C-s in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-s") 'abort-recursive-edit)))

;; (global-set-key (kbd "C-x C-b") 'switch-to-buffer) ; instead of 'list-buffers (see helm)
;; (global-set-key (kbd "C-x b") 'ibuffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer)  
#+END_SRC

* Major modes

** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode										; for improved html support
	:ensure t
	:mode
	("\\.phtml\\'" . web-mode)
	("\\.tpl\\.php\\'" . web-mode)
	("\\.[agj]sp\\'" . web-mode)
	("\\.as[cp]x\\'" . web-mode)
	("\\.erb\\'" . web-mode)
	("\\.mustache\\'" . web-mode)
	("\\.djhtml\\'" . web-mode)
	("\\.html?\\'" . web-mode)
	("\\.xml\\'" . web-mode)
	("\\.css\\'" . web-mode)
	:config
	;; highlight enclosing tags of the element under cursor
  (setq web-mode-enable-current-element-highlight t)
)
#+END_SRC

** Python

*** elpy

Prerequisites as for Python:
#+BEGIN_SRC bash
	sudo pip install jedi flake8 importmagic autopep8 # Elpy's recommendation
	sudo pip install pylint virtualenv epc # Zamansky's recommendation
#+END_SRC

#+BEGIN_SRC emacs-lisp
	(use-package elpy
		:ensure t
		:defer 2
		:config
		(progn
			;; Use Flycheck instead of Flymake
			(when (require 'flycheck nil t)
				(remove-hook 'elpy-modules 'elpy-module-flymake)
				(remove-hook 'elpy-modules 'elpy-module-yasnippet)
				(remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
				(add-hook 'elpy-mode-hook 'flycheck-mode))
			(elpy-enable)
			(define-key python-mode-map (kbd "C-h f") 'python-eldoc-at-point)
			;; highlight-indentation is ugly
			(add-hook 'elpy-mode-hook '(lambda () (highlight-indentation-mode -1)))
			;; jedi is great
			(setq elpy-rpc-backend "jedi")))
#+END_SRC

*** company-jedi

#+BEGIN_SRC emacs-lisp
;; Use Company for auto-completion interface.
(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi))

(use-package company-jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'my/python-mode-hook))
#+END_SRC

** PlantUML

Depends on plantuml.jar and Gaphviz (http://www.graphviz.org).

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :ensure t
  :mode ("\\.plu\\'" "\\.puml\\'") 
  :init
	(setq org-plantuml-jar-path
				(expand-file-name "plantuml.jar" wemacs-dir))
	(setq plantuml-jar-path
				(expand-file-name "plantuml.jar" wemacs-dir)))
#+END_SRC

** dired

*** General settings

Tips:  http://ergoemacs.org/emacs/emacs_dired_tips.html

Do not open new buffer when opening a file/directory: 
#+BEGIN_SRC emacs-lisp
;; (define-key dired-mode-map (kbd "<return>") 'dired-find-alternate-file) ; was dired-advertised-find-file
(define-key dired-mode-map (kbd "<backspace>") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory
(define-key dired-mode-map (kbd "<left>") (lambda () (interactive) (find-alternate-file "..")))  ; was 
#+END_SRC

View file and return to dired with q:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<tab>") 'dired-view-file)
(define-key dired-mode-map (kbd "<right>") 'dired-view-file)
(add-hook 'view-mode-hook
  (lambda ()
    (define-key view-mode-map (kbd "<left>") 'View-quit)
		(define-key view-mode-map (kbd "<right>") 'View-exit-and-edit)
    ))
#+END_SRC

Copy/move into other dired buffer:
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

Show details of files and directories:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook
          (lambda () (dired-hide-details-mode -1)))
#+END_SRC

Don't break lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-initial-position-hook '(lambda () (setq truncate-lines t)))
;; (add-hook 'dired-mode-hook (lambda () (setq truncate-lines t)))
#+END_SRC

Order directories first (only windows?):
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-dirs-first t)
#+END_SRC

Other settings: http://oremacs.com/2015/01/13/dired-options/

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-laGh1v")
#+END_SRC

*** Mark/Unmark 

Use shift-up and shift-down in the usual way.
See http://emacs.stackexchange.com/a/30890/12336
#+BEGIN_SRC emacs-lisp
(defun my-dired-toggle (arg)
  (save-restriction
    (narrow-to-region (point-at-bol) (point-at-eol))
    (dired-toggle-marks))
	(dired-previous-line arg))

(defun my-dired-mark-up ()
  (interactive)
  (my-dired-toggle 1))

(defun my-dired-mark-down ()
  (interactive)
  (my-dired-toggle -1))

(define-key dired-mode-map (kbd "<S-up>") 'my-dired-mark-up)
(define-key dired-mode-map (kbd "<S-down>") 'my-dired-mark-down)
#+END_SRC

*** TODO COMMENT Open binary files in external programm

#+BEGIN_SRC
advice(dired-find-file :before)
if (dired-get-file-for-visit ~= /^.*\.(pdf|wav|mp3|flac|...)/ ) {
  xah-open-in-external-app(dired-get-file-for-visit)
  return t
} 
#+END_SRC

*** Open in external programm

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2016-10-15"
  (interactive)
  (let* (
         (-file-list
          (if (string-equal major-mode "dired-mode")
              (dired-get-marked-files)
            (list (buffer-file-name))))
         (-do-it-p (if (<= (length -file-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))
    (when -do-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (-fpath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" -fpath t t))) -file-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (-fpath)
           (shell-command
            (concat "open " (shell-quote-argument -fpath))))  -file-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (-fpath) (let ((process-connection-type nil))
                            (start-process "" nil "xdg-open" -fpath))) -file-list))))))

(define-key dired-mode-map (kbd "C-<return>") 'xah-open-in-external-app)
#+END_SRC

*** Open in external file browser

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-desktop ()
  "Show current file in desktop (OS's file manager).
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2015-11-30"
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux")
    (let (
          (process-connection-type nil)
          (openFileProgram (if (file-exists-p "/usr/bin/gvfs-open")
                               "/usr/bin/gvfs-open"
                             "/usr/bin/xdg-open")))
      (start-process "" nil openFileProgram "."))
    ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. For example: with nautilus
    )))
#+END_SRC

*** dired-imenu

#+BEGIN_SRC emacs-lisp
(use-package dired-imenu
	:ensure t
	:init
	(require 'dired-imenu)
)
#+END_SRC

*** dired-k

#+BEGIN_SRC emacs-lisp
(use-package dired-k
	:ensure t
	:bind (:map dired-mode-map ("K" . dired-k))
	:config
  (progn
		;; FIXME: Tramp prompts for the password in every new dired buffer!
		;; (add-hook 'dired-initial-position-hook 'dired-k)
		;; (add-hook 'dired-after-readin-hook #'dired-k-no-revert)
))
#+END_SRC

*** TODO COMMENT dired-quick-sort

Depends on ls

#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
	:ensure t
	:init
	(require 'dired-quick-sort)
	(dired-quick-sort-setup)
	)
#+END_SRC

*** TODO dired-narrow

Filter dired list on the fly:

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
							("/" . dired-narrow)
							:map dired-narrow-map
              ("<tab>" . dired-narrow-enter-directory)
              ("<right>" . dired-view-file)
							("<return>" . exit-minibuffer))        
	:config
	(setq dired-narrow-exit-action 'dired-narrow-find-file)
)
#+END_SRC

*** dired+

#+BEGIN_SRC emacs-lisp
(use-package dired+
  :ensure t
  :config
  (require 'dired+)
  (setq diredp-hide-details-initially-flag nil)
  (set-face-foreground 'diredp-file-name nil)
  ;; Keep dired buffers updated when the file system changes.
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil))
#+END_SRC

<mouse-1> opens file/directory in the same window:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<mouse-2>") 'diredp-mouse-find-file)
#+END_SRC

*** dired-ranger

#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
	:ensure t
  :config
  (setq dired-ranger-copy-ring-size 1)
	(define-key dired-mode-map (kbd "C-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)	; t adds item to dired-ranger-copy-ring
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-move)))
	(define-key dired-mode-map (kbd "M-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-paste)))
)
#+END_SRC

*** TODO peep-dired
** js2-mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode										; for improved JavaScript support
	:ensure t
	:mode
	("\\.js\\'" . js2-mode))
#+END_SRC

** org-mode

Must appear before LaTeX stuff!

http://pages.sachachua.com/.emacs.d/Sacha.html#orgfe5d909
http://doc.norang.ca/org-mode.html#Setup

*** Files

#+BEGIN_SRC emacs-lisp
(defun tl/update-org-agenda-files ()
	(interactive)
  (setq org-agenda-files ())
  (load-org-agenda-files-recursively (expand-file-name (concat org-notes-dir "/"))) ; trailing slash required

	;; ;; The following code does not search the org directory recursively:
  ;; (setq org-agenda-files
	;; 			(append
	;; 			 (list org-directory)
	;; 			 (file-expand-wildcards (concat org-directory "/*/*.org"))))

	(add-links-to-org-agenda-files) ; of the current buffer
	(customize-save-variable 'org-agenda-files org-agenda-files)
	(message "org-agenda-files updated")
	)

;; Copied from http://stackoverflow.com/a/26548971/6452961
(defun load-org-agenda-files-recursively (dir) "Find all directories in DIR."
			 (unless (file-directory-p dir) (error "Not a directory `%s'" dir))
			 (unless (equal (directory-files dir nil org-agenda-file-regexp t) nil)
				 (add-to-list 'org-agenda-files dir)
				 )
			 (dolist (file (directory-files dir nil nil t))
				 (unless (member file '("." ".."))
					 (let ((file (concat dir file "/")))
						 (when (file-directory-p file)
							 (load-org-agenda-files-recursively file)
							 )
						 )
					 )
				 )
			 )

	;; (if (eq org-agenda-files nil)						; FIXME
	;; 		()
	;; 	())

	;; ;; Doing this at every start-up is maybe not a good idea:
	;; (setq org-agenda-files
	;; 			(append
	;; 			 (list org-directory)
	;; 			 (file-expand-wildcards (concat org-notes-dir "/*/*.org"))))

	;; set refile targets to move entries inside org-agenda 
	(setq org-refile-targets '(
														 (nil :maxlevel . 2)             ; refile to headings in the current buffer
														 (org-agenda-files :maxlevel . 2) ; refile to any of these files
														 ))
#+END_SRC

*** Archive

Preserves the first heading of the org-mode file (found in http://orgmode.org/worg/org-hacks.html#orgheadline59):

#+BEGIN_SRC emacs-lisp
(defadvice org-archive-subtree (around my-org-archive-subtree activate)
  (let ((org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it))
#+END_SRC

*** babel

Preserve indentation in source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

*** General keys

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9> c") 'org-goto-calendar)
  (global-set-key (kbd "<f9> a") 'org-agenda-list)
  (global-set-key (kbd "<f9> t") 'org-todo-list)
  (global-set-key (kbd "C-<f9>") 'org-cycle-agenda-files)
  (global-set-key (kbd "<f9> s") 'org-search-view)
  (global-set-key (kbd "<f9> f") 'org-search-view)
  (global-set-key (kbd "<f9> l") 'org-tags-view)
  (global-set-key (kbd "<f9> r") 'org-reload)
  (global-set-key (kbd "<f9> w")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/forschung/wip.org"))))
  (global-set-key (kbd "<f9> n")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/notes.org"))))
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-<tab>") nil )
    (define-key org-mode-map (kbd "S-<up>") nil )
    (define-key org-mode-map (kbd "S-<down>") nil )
    ;; (define-key org-mode-map (kbd "S-<left>") nil )
    ;; (define-key org-mode-map (kbd "S-<right>") nil )
    (define-key org-mode-map (kbd "C-c C-f") 'org-footnote-action )
    (define-key org-mode-map (kbd "C-c C-x C-b") 'org-tree-to-indirect-buffer ))

  ;; (with-eval-after-load 'org-agenda
  ;;   (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+END_SRC

*** General appearence

**** Lists

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

**** Color text

#+BEGIN_SRC emacs-lisp
(require 'org-colored-text)
#+END_SRC

**** Fonts

#+begin_src emacs-lisp
	(add-hook 'org-mode-hook (lambda ()
														 (variable-pitch-mode t)
														 ;; (text-scale-increase 0.5)
														 ))

	;; (set-face-attribute 'org-block-background nil :inherit 'fixed-pitch)
	(custom-set-variables
	 '(org-ref-label-color "magenta")
	 '(org-ref-ref-color "Deepskyblue1")
	 )
	(custom-set-faces
	 '(org-done ((t (:overline t))))
	 '(org-todo ((t (:overline t))))
	 '(org-block ((t (:inherit fixed-pitch :background "#3E3D31")))) ; org-mode >9
	 '(org-block-background ((t (:inherit fixed-pitch :background "#3E3D31"))))
	 '(org-block-begin-line ((t (:underline t))))
	 '(org-block-end-line  ((t (:overline t))))
	 '(org-level-1 ((t (:inherit outline-1 :overline t :height 1.5))))
	 '(org-level-2 ((t (:inherit outline-2 :overline t :height 1.25))))
	 '(org-level-3 ((t (:inherit outline-3 :height 1.1))))
	 '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
	 '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
	 )

	(with-eval-after-load 'org
		(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-latex-and-related nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-link nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
		)

	(setq org-hide-emphasis-markers t)

#+end_src

**** Bullets, folding symbols, HTML and LaTeX symbols

#+begin_src emacs-lisp
;; nicer bullets
;; (use-package org-bullets
;; 	:ensure t
;; 	:init
;; 	(setq org-bullets-bullet-list
;; 				'("◉" "◎" "○" "●" "►" "♦" "◇"))
;; 	:config 
;; 	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
;; 	)

;; folding symbol
(setq org-ellipsis " ▼")

;; replace HTML/LaTeX code by UTF-8 characters (see org-pretty-entities for an enumeration)
(setq org-pretty-entities t)

#+END_SRC

*** Modules

See http://orgmode.org/worg/org-contrib/

#+BEGIN_SRC emacs-lisp
;; (setq org-modules '( ;; org-bbdb
;;                       ;; org-gnus
;;                       ;; org-drill
;;                       ;; org-info
;;                       ;; org-jsinfo
;;                       ;; org-habit
;;                       ;; org-irc
;;                       ;; org-mouse
;;                       ;; org-protocol
;;                       ;; org-annotate-file
;;                       ;; org-eval
;;                       ;; org-expiry
;;                       ;; org-interactive-query
;;                       ;; org-man
;;                       ;; org-collector
;;                       ;; org-panel
;;                       ;; org-screen
;;                       ;; org-toc
;; 											))
;; (eval-after-load 'org
;;  '(org-load-modules-maybe t))
;; (setq org-expiry-inactive-timestamps t)
#+END_SRC

*** Miscellaneous settings

Selection
#+BEGIN_SRC emacs-lisp
(setq org-support-shift-select t)
#+END_SRC

Source blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Todo lists
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

Links
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

Block
#+BEGIN_SRC emacs-lisp
(setq org-hide-block-startup t) 				; hide blocks at startup
#+END_SRC

Indent automatically
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

Support for inline tasks
#+BEGIN_SRC emacs-lisp
(load "org-inlinetask")
(define-key org-mode-map (kbd "C-c C-x C-t") 'org-inlinetask-insert-task)
#+END_SRC

C-a and C-e behave org-sensitive
#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
#+END_SRC

*** Newline

#+BEGIN_SRC emacs-lisp
  (defun tl/org-return ()
    (interactive)
    (if (not (org-table-p))
        (org-return)
      (let ((home (point)))
        (org-table-insert-row t)
        (goto-char home))
      (org-table-wrap-region nil))
  )

  (defun tl/org-shift-return ()
    (interactive)
    (let ((home (point)))
      (org-table-insert-row t)
      (goto-char home))
    (org-table-next-row)
  )

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<return>") 'tl/org-return) ; not org-table-next-row
    (define-key org-mode-map (kbd "S-<return>") 'tl/org-shift-return )) ; not org-table-copy-down
#+END_SRC

*** LaTeX support

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((latex . t)))
(setq org-highlight-latex-and-related '(latex script entities)) ; inline sytax highlighting
;; (add-to-list 'org-latex-packages-alist '("" "tikz" t))					; unfortunately this breaks the color of fonts in inline previews
;; (add-to-list 'org-latex-packages-alist '("" "forest" t))
#+END_SRC

Scale LaTeX previews:
#+BEGIN_SRC emacs-lisp
;; static
;; (plist-put org-format-latex-options :scale 2) ; scale inline PNGs

;; dynamic (http://emacs.stackexchange.com/a/13032/12336)
(defun update-org-latex-fragment-scale ()
  (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
    (plist-put org-format-latex-options :scale (* 2.3 text-scale-factor)))
)
(add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale)
#+END_SRC

*** org-ref

#+BEGIN_SRC emacs-lisp
;; (setq org-ref-completion-library 'org-ref-ivy-cite) ; must appear before org-ref
(use-package org-ref
	:ensure t
	:after org
	:init
	(require 'org-ref) 										; don't know why I need this
	(setq org-ref-default-bibliography user-bibliography-file
				;; org-ref-bibliography-notes "~/bibliography/notes.org"
				org-ref-pdf-directory user-bibliography-pdf-dir
				)
	:config
	:bind (:map org-mode-map
							("C-c ]" . org-ref-helm-insert-cite-link)
							("C-c )" . org-ref-helm-insert-ref-link)
							("C-c (" . org-ref-helm-insert-label-link))
)
#+END_SRC

*** org-reveal

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
	:ensure ox-reveal)

;; (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-root "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.4.1/")
(setq org-reveal-mathjax t)

(use-package htmlize
	:ensure t)
#+END_SRC

*** Plantuml

http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html

 #+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages  'org-babel-load-languages '((plantuml . t)))
#+END_SRC

*** Spell checking
#+BEGIN_SRC emacs-lisp
;; ispell
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
;; flyspell
;; http://emacs.stackexchange.com/a/9347/12336
;; NO spell check for embedded snippets
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let ((rlt ad-return-value)
        (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
        (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
        old-flag
        b e)
    (when ad-return-value
      (save-excursion
        (setq old-flag case-fold-search)
        (setq case-fold-search t)
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t)))
        (setq case-fold-search old-flag))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

*** Agenda

Don't split window when opening agenda:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup "only-window")
#+END_SRC

Show notifications of agenda events:
#+BEGIN_SRC emacs-lisp
(use-package org-alert
	:ensure t
	)
#+END_SRC

Add linked org-mode files to =org-agenda-files=:
(FIXME: Does it capture links inside properties?)
#+BEGIN_SRC emacs-lisp 
	(defun add-links-to-org-agenda-files ()
		"Inspired by: http://stackoverflow.com/questions/38061773/add-linked-org-files-to-org-agenda-files"
		 (interactive)
		 (princ "Added the following files to org-agenda-files:")
		 (org-element-map  
				 (org-element-parse-buffer)
				 'link
			 (lambda (x)
				 (let ((org-link-path (org-element-property :path x))
							 (org-link-type (org-element-property :type x)))
					 (when (and (equal org-link-type "file") ; only links to files
										(string-prefix-p "~/" org-link-path) ; relative paths are bad
										(equal "org" (file-name-extension org-link-path)) ;only org-mode files
										(file-exists-p org-link-path) ; only existing files
										)
							 (princ (concat " " org-link-path))
							 (add-to-list 'org-agenda-files org-link-path)
					 )))))
#+END_SRC

Integrate Google Calendar with org-gcal:
#+BEGIN_SRC emacs-lisp
	(setq package-check-signature nil)

	(use-package org-gcal
		:ensure t
		:config
		(when (load-file (expand-file-name "gcal-credentials.el" private-emacs-settings-dir))
			(setq org-gcal-client-id my-org-gcal-client-id
						org-gcal-client-secret my-org-gcal-client-secret
						org-gcal-file-alist '((my-gmail-address .  "~/Dropbox/Notizen/org/gcal.org")))
	))
#+END_SRC

*** Links

Links to files are opened in the same window, i.e. the window does not get split:
#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((file . find-file)))
#+END_SRC

*** Tags

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist
			'((:startgroup . nil)
				("@work" . ?w)
				(:grouptags . nil)
				("admin" . ?a)
				("teaching" . ?t)
				("research" . ?r)
				(:endgroup . nil)

				(:startgroup . nil)
				("research" . ?r)
				(:grouptags . nil)
				("mwe" . nil)									
				("parsing" . nil)
				("linguistics" . nil)
				("formalisms" . nil)
				("philosophy" . nil)
				("logic" . nil)
				("maths" . nil)
				("computerScience" . nil)
				("xmg" . nil)											
				(:endgroup . nil)

				(:startgroup . nil)
				("science" . ?h)
				(:grouptags . nil)
				("linguistics" . nil)
				("computationalLinguistics" . nil)
				("philosophy" . nil)
				("logic" . nil)
				("maths" . nil)
				("computerScience" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("linguistics" . ?h)
				(:grouptags . nil)
				("syntax" . nil)
				("semantics" . nil)
				("pragmatics" . nil)
				("phonology" . nil)
				("morphology" . nil)
				("corpora" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("computationalLinguistics" . ?h)
				(:grouptags . nil)
				("parsing" . nil)
				("generation" . nil)
				("formalisms" . nil)
				("corpora" . nil)
				("speechRecognition" . nil)
				("machineLearning" . nil)
				(:endgroup . nil)

				
				(:startgroup . nil)
				("@home" . ?h)
				(:grouptags . nil)
				("spenden" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("software" . ?h)
				(:grouptags . nil)
				("programming" . nil)
				("nlp" . nil)
				("os" . nil)
				("xmg" . nil)											
				(:endgroup . nil)

				(:startgroup . nil)
				("programming" . ?p)
				(:grouptags . nil)
				("emacs" . ?m)
				("latex" . ?x)
				("langsci" . ?l)
				("python" . ?y)
				("javascript" . ?j)
				("perl" . nil)
				("php" . nil)
				("shellscript" . nil)											
				(:endgroup . nil)
				))
#+END_SRC

*** Tables

http://emacs.stackexchange.com/a/28298/12336
#+BEGIN_SRC emacs-lisp
(defun org-table-goto-col-beginning ()
  "Go to beginning of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (org-table-begin))
    (org-table-goto-column col))
  (point))

(defun org-table-col-beginning ()
  "Return beginning position of current column."
  (save-excursion
    (org-table-goto-col-beginning)))

(defun org-table-goto-col-end ()
  "Goto end of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (1- (org-table-end)))
    (org-table-goto-column col)
    (skip-chars-forward "^|"))
  (point))

(defun org-table-col-end ()
  "Return end position of current column."
  (save-excursion
    (org-table-goto-col-end)))

(defun org-table-select-col ()
  "Select current column."
  (interactive)
  (set-mark (org-table-col-beginning))
  (org-table-goto-col-end))

(defun org-table-copy-col ()
  "Copy current column."
  (interactive)
  (save-excursion
    (org-table-copy-region (org-table-goto-col-beginning)
													 (org-table-goto-col-end))))
#+END_SRC

*** Capture templates

#+BEGIN_SRC emacs-lisp
	(setq org-capture-templates
				'(("a" "Appointment" entry (file (concat org-notes-dir "/gcal.org"))
					 "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
					("t" "Todo" entry (file (concat org-notes-dir "/todo.org"))
					 "* TODO %?\t%^g\n CREATED: %U\n About region:%i\n %a")
					("n" "Note" entry (file+datetree (concat org-notes-dir "/notes.org"))
					 "* %?\t%^g\n CREATED: %U\n About region:%i\n %a")
					("c" "Code" entry (file (concat org-notes-dir "/code.org"))
					 "* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC\n CREATED: %U\n About region:%i\n %a")
					))

	(global-set-key (kbd "<f9> <f9>") 'org-capture)
	;; (global-set-key (kbd "<f9> <f9> t") (lambda () (interactive) (org-capture nil "t")))
#+END_SRC

*** Todo keywords

#+BEGIN_SRC emacs-lisp
;; (setq org-todo-keywords
;;       (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
;;               (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

;; (setq org-todo-keyword-faces
;;       (quote (("TODO" :foreground "red" :weight bold)
;;               ("NEXT" :foreground "blue" :weight bold)
;;               ("DONE" :foreground "forest green" :weight bold)
;;               ("WAITING" :foreground "orange" :weight bold)
;;               ("HOLD" :foreground "magenta" :weight bold)
;;               ("CANCELLED" :foreground "forest green" :weight bold)
;;               ("MEETING" :foreground "forest green" :weight bold)
;;               ("PHONE" :foreground "forest green" :weight bold))))
#+END_SRC

** Calendar

#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)

  (setq calendar-intermonth-text
        '(propertize
          (format "%2d"
                  (car
                   (calendar-iso-from-absolute
                    (calendar-absolute-from-gregorian (list month day year)))))
          'font-lock-face 'font-lock-warning-face))

  (setq calendar-intermonth-header
        (propertize "KW"                  ; or e.g. "KW" in Germany
                    'font-lock-face 'font-lock-keyword-face))

#+END_SRC

*** German holidays

#+BEGIN_SRC emacs-lisp
  (use-package german-holidays
    :ensure t
    :config
    (setq calendar-holidays holiday-german-holidays)
    ;; (setq calendar-holidays holiday-german-BW-holidays)
    )
#+END_SRC

*** calfw 

http://jameswilliams.be/blog/2016/01/11/Taming-Your-GCal.html

 #+BEGIN_SRC emacs-lisp
(use-package calfw
	:ensure ;TODO: 
	:init
	(require 'calfw-org)
	(require 'calfw-ical)
	(setq cfw:render-line-breaker 'cfw:render-line-breaker-simple)

	(defvar user-calendar-settings-file
		(expand-file-name "calendar-calfw-settings.el" private-emacs-settings-dir))

	(if (file-exists-p user-calendar-settings-file)
			(load-file user-calendar-settings-file)
		(display-warning "calfw" (concat "Could not load " user-calendar-settings-file)))
	)

(define-key cfw:calendar-mode-map (kbd "u") 
	'(lambda () (interactive)
		 (when (fboundp 'tl/update-my-calendars) ; tl/update-my-calendars is defined in  user-calendar-settings-file
			 (tl/update-my-calendars))
		 (my-open-calfw)
		 ))

#+END_SRC

** LaTeX

*** AUCTeX 

#+BEGIN_SRC emacs-lisp
	(use-package tex
		:ensure auctex												; because auctex overwrites tex

		:init

		;; to activate auctex
		(setq TeX-auto-save t)  
		(setq TeX-auto-local
					(expand-file-name "temp" user-emacs-directory))
		(setq TeX-parse-self t)
		(setq-default TeX-master nil)
		(setq TeX-save-query nil) ; autosave before compiling 
		;; (setq TeX-show-compilation t) ; always show and follow TeX output

		;; don't indent
		(setq LaTeX-indent-level 0)
		(setq LaTeX-item-indent 0)

		;; viewer
		(setq TeX-PDF-mode t)
		(setq TeX-source-correlate-mode t)
		(setq TeX-source-correlate-method 'synctex)
		(setq TeX-view-program-list
					'(("Sumatra PDF" ("\"C:/Program Files (x86)/SumatraPDF/SumatraPDF.exe\" -reuse-instance"
														(mode-io-correlate " -forward-search %b %n ") " %o"))))
		(eval-after-load 'tex
			'(progn
				 (assq-delete-all 'output-pdf TeX-view-program-selection)
				 (add-to-list 'TeX-view-program-selection '(output-pdf "Sumatra PDF"))))
		
		;; make LaTeXmk default
		(use-package auctex-latexmk
			:ensure t
			:config
			(auctex-latexmk-setup)
			(setq auctex-latexmk-inherit-TeX-PDF-mode t)
			(setq TeX-command-force "LatexMk")  ; remember to set path variable accordingly!
			)
		
		:config
	
		;; ;; ivy-bibtex
		;; (use-package ivy-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; (define-key LaTeX-mode-map (kbd "C-l C-r") 'ivy-bibtex)
		;; 	;; The standard function with modified default action  
		;; 	(defun ivy-bibtex (&optional arg)
		;; 		"Search BibTeX entries using ivy. With a prefix ARG the cache is invalidated and the bibliography reread."
		;; 		(interactive "P")
		;; 		(when arg
		;; 			(setq bibtex-completion-bibliography-hash ""))
		;; 		(bibtex-completion-init)
		;; 		(ivy-read "BibTeX Items: "
		;; 							(bibtex-completion-candidates 'ivy-bibtex-candidates-formatter)
		;; 							:caller 'ivy-bibtex
		;; 							:action 'bibtex-completion-insert-key))
		;; 	;; look for local bibliographies
		;; 	;; (require 'ebib)
		;; 	(defun ivy-bibtex-with-local-bibliography ()
		;;     (interactive)
		;;     (let ((bibtex-completion-bibliography
		;; 					 (if (eq major-mode 'latex-mode)
		;; 							 ;; (ebib--get-local-databases)
		;; 							 (bibtex-completion--get-local-databases)
		;; 						 bibtex-completion-bibliography)))
		;; 			(ivy-bibtex)))
		;; 	;; proposal by jagrg: https://github.com/tmalsburg/helm-bibtex/issues/112 
		;; 	(defun bibtex-completion--get-local-databases ()
		;; 		"Return a list of .bib files associated with the current file."
		;; 		(let ((texfile nil)
		;; 					(cb (current-buffer)))
		;; 			(when (and (boundp 'TeX-master)
		;; 								 (stringp TeX-master))
		;; 				(setq texfile (if (file-name-extension TeX-master)
		;; 													TeX-master
		;; 												(concat TeX-master ".tex"))))
		;; 			(with-temp-buffer
		;; 				(if (and texfile (file-readable-p texfile))
		;; 						(insert-file-contents texfile)
		;; 					(insert-buffer-substring cb))
		;; 				(save-match-data
		;; 					(goto-char (point-min))
		;; 					(cond
		;; 					 ;; bibtex
		;; 					 ((re-search-forward "\\\\\\(?:no\\)*bibliography{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(split-string (match-string-no-properties 1) ",[ ]*")))
		;; 					 ;; biblatex
		;; 					 ((re-search-forward "\\\\addbibresource\\(\\[.*?\\]\\)?{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(let ((option (match-string 1))
		;; 													(file (match-string-no-properties 2)))
		;; 											(unless (and option (string-match-p "location=remote" option))
		;; 												(split-string file ",[ ]*")))))
		;; 					 (t
		;; 						bibtex-completion-bibliography))))))
		;; 	:bind (:map LaTeX-mode-map 
		;; 							("C-l C-r" . ivy-bibtex-with-local-bibliography))
		;; 	)

		;; see  pull request: https://github.com/tmalsburg/helm-bibtex/pull/113
		;; ;; helm-bibtex FIXME: 
		;; (use-package helm-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; The standard function with modified default action  
		;; 	;; :bind (:map LaTeX-mode-map ("C-l C-r" . helm-bibtex-with-local-bibliography))
		;; 	)

		;; font keys
		(defun TeX-italic()
			(interactive)
			(TeX-font nil ?\C-i))
		(defun TeX-bold()
			(interactive)
			(TeX-font nil ?\C-b))
		(defun TeX-typewriter()
			(interactive)
			(TeX-font nil ?\C-t))
		(defun TeX-emphasis()
			(interactive)
			(TeX-font nil ?\C-e))
		(defun TeX-smallcaps()
			(interactive)
			(TeX-font nil ?\C-c))
		(defun TeX-italic-replace()
			(interactive)
			(TeX-font t ?\C-i))
		(defun TeX-bold-replace()
			(interactive)
			(TeX-font t ?\C-b))
		(defun TeX-typewriter-replace()
			(interactive)
			(TeX-font t ?\C-t))
		(defun TeX-emphasis-replace()
			(interactive)
			(TeX-font t ?\C-e))
		(defun TeX-smallcaps-replace()
			(interactive)
			(TeX-font t ?\C-c))
		(defun TeX-deletefont()
			(interactive)
			(TeX-font nil ?\C-d))
		(define-key LaTeX-mode-map (kbd "C-c C-f i") 'TeX-italic)
		(define-key LaTeX-mode-map (kbd "C-c C-f b") 'TeX-bold)
		(define-key LaTeX-mode-map (kbd "C-c C-f t") 'TeX-typewriter)
		(define-key LaTeX-mode-map (kbd "C-c C-f e") 'TeX-emphasis)
		(define-key LaTeX-mode-map (kbd "C-c C-f s") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c C-f c") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c C-f d") 'TeX-deletefont)	
		(define-key LaTeX-mode-map (kbd "C-c C-f DEL") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c f i") 'TeX-italic)
		(define-key LaTeX-mode-map (kbd "C-c f b") 'TeX-bold)
		(define-key LaTeX-mode-map (kbd "C-c f t") 'TeX-typewriter)
		(define-key LaTeX-mode-map (kbd "C-c f e") 'TeX-emphasis)
		(define-key LaTeX-mode-map (kbd "C-c f s") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c f c") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c f d") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c f DEL") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! i") 'TeX-italic-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! b") 'TeX-bold-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! t") 'TeX-typewriter-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! e") 'TeX-emphasis-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! s") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! c") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! i") 'TeX-italic-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! b") 'TeX-bold-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! t") 'TeX-typewriter-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! e") 'TeX-emphasis-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! s") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! c") 'TeX-smallcaps-replace)
	
		:bind (:map  LaTeX-mode-map
								 ;; ("C-l C-q" . align-current) ; useful command to align arrays
								 ;; ("C-l H-i" . align-current) ; useful command to align arrays							 
								 ;; keys for error browsing (disabled; see hydra settings)
								 ;; ("<f4>" . TeX-next-error)	 
								 ;; ("S-<f4>" . TeX-previous-error)
								 ;; ("C-<f4>" . TeX-error-overview)
								 ;; miscellaneous keys
								 ("C-c <backspace>" . TeX-clean)
								 ("C-<return>" . LaTeX-close-environment)
								 ;; goto keys
								 ("C-c {" . LaTeX-find-matching-begin)
								 ("C-c }" . LaTeX-find-matching-end)
								 )
		)

	;; unset key for preview 
	(add-hook 'LaTeX-mode-hook
						'(define-key LaTeX-mode-map (kbd "C-c C-p") nil))

#+END_SRC

*** reftex

#+BEGIN_SRC emacs-lisp
(use-package reftex
	:diminish reftex-mode
	:init
	(add-hook 'latex-mode-hook 'turn-on-reftex)
	(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
	(setq reftex-plug-into-AUCTeX t
				;; reftex-ref-style-default-list '("Cleveref" "Hyperref" "Fancyref")
				;; reftex-toc-split-windows-horizontally t
				reftex-ref-macro-prompt nil			; go straight to the labels when referencing
				reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")
				reftex-default-bibliography '(user-bibliography-file)
				)

	;; add frametitle to TOC
	(setq reftex-section-levels '(("part" . 0)
																("chapter" . 1)
																("section" . 2)
																("subsection" . 3)
																("subsubsection" . 4)
																("frametitle" . -3)
																("paragraph" . 5)
																("subparagraph" . 6)
																("addchap" . -1)
																("addsec" . -2)))
	
	;; connect reftex to imenu
	(add-hook 'reftex-load-hook 'imenu-add-menubar-index)
	(add-hook 'reftex-mode-hook 'imenu-add-menubar-index)
	
	:config
	
	;; jumping around like in org-mode
	(define-key LaTeX-mode-map (kbd "C-c C-j") 'tl/reftex-in-follow-mode)
	(define-key LaTeX-mode-map (kbd "C-c C-n") 'tl/reftex-next)
	(define-key LaTeX-mode-map (kbd "C-c C-p") 'tl/reftex-previous)
	(defun tl/reftex-in-follow-mode()
		(interactive)
		(setq reftex-toc-follow-mode t)
		(reftex-toc))
	(defun tl/reftex-next ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-next)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	(defun tl/reftex-previous ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-previous)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	
	:bind (:map LaTeX-mode-map
							("C-c ]" . reftex-citation); same as in org-mode
						  ) 
	)
#+END_SRC

*** Beamer

Add \frametitle to outline (and imenu):
#+BEGIN_SRC emacs-lisp
(add-to-list 'TeX-outline-extra '("\\\\frametitle\\b" 4))
#+END_SRC

*** Misc

Make square brackets indent correctly (testing):
#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?\[ "(]" LaTeX-mode-syntax-table)
(modify-syntax-entry ?\] ")[" LaTeX-mode-syntax-table)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
	:ensure t
	:config 
	(defun my-markdown-mode-config ()
		"settings for markdown mode"
		(interactive)
		(setq-default tab-width 4)
		(setq-default indent-tabs-mode t)
		(setq markdown-enable-math t))
	(add-hook 'markdown-mode 'my-markdown-mode-config)
	(setq markdown-enable-math t)
	)
#+END_SRC

** Deft

#+BEGIN_SRC emacs-lisp
(use-package deft												; for displaying list of note files
	:ensure t
  :bind
	("<f9> f" . deft)
	("<f9> o" . deft)
	("<f9> d" . deft)
  :commands (deft)
  :config (setq deft-directory org-notes-dir
                deft-extensions '("md" "org")
								deft-recursive t
								deft-use-filename-as-title t
								deft-use-filter-string-for-filename t))
#+END_SRC

** Pomodoro technique

Tomatinho brings the promodoro technique to Emacs:
#+BEGIN_SRC emacs-lisp
(use-package tomatinho
	:ensure t
	)
#+END_SRC

* Buffer

** General configuration

Automatically update buffers when files change:
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+end_src

Visible bell:
#+begin_src emacs-lisp
(setq visible-bell t)
(setq ring-bell-function (lambda ()
                           (invert-face 'mode-line)
                           (run-with-timer 0.05 nil 'invert-face 'mode-line)))
#+end_src

Delete marked text on typing:
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Use tabs for indent:
#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode t)
#+end_src

Scrolling:
#+begin_src emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000)
;; autoscroll compilation output
(setq compilation-scroll-output t)
;; scroll to the first/last line
(setq scroll-error-top-bottom t)
#+end_src

Show vertical line per indentation level: 
#+begin_src emacs-lisp
(use-package highlight-indent-guides
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
	(setq highlight-indent-guides-method 'character)
	)
#+end_src

** Autocomplete

*** yasnippet (before auto-complete)

#+begin_src emacs-lisp
(use-package yasnippet
	:ensure t
	:config (yas-global-mode 1))
#+end_src

*** auto-complete
Sequence is important!

#+begin_src emacs-lisp
;; (require 'auto-complete)
;; (require 'auto-complete-auctex)
;; (require 'auto-complete-config)
;; (ac-config-default)
;; (setq ac-auto-show-menu t)
;; (setq ac-auto-show-menu 1)
;; (global-auto-complete-mode 1)
;; ;; (add-to-list 'ac-modes 'latex-mode)     ; activate auto-complete for latex <modes (AUCTeX or Emacs' builtin one).
;; (add-hook 'latex-mode-hook (function (lambda ()
;; 																					(ac-source-yasnippet))))
#+end_src

*** company
#+begin_src emacs-lisp
(use-package company
	:ensure t
	:config

	(use-package company-auctex
		:ensure t
		:config (company-auctex-init))
	(add-hook 'after-init-hook 'global-company-mode)

	;; yasnippet integration
	(defvar company-mode/enable-yas t
		"Enable yasnippet for all backends.")
	(defun company-mode/backend-with-yas (backend)
		(if (or (not company-mode/enable-yas)
						(and (listp backend) (member 'company-yasnippet backend)))
				backend
			(append (if (consp backend) backend (list backend))
							'(:with company-yasnippet))))
	(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

	;; some general variables
	(setq company-idle-delay 0.3
				company-minimum-prefix-length 1
				company-selection-wrap-around t
				;; company-show-numbers t
				company-dabbrev-downcase nil
				company-auto-complete nil
				company-transformers '(company-sort-by-occurrence))
	(add-hook 'eshell-mode-hook '(lambda () (setq company-idle-delay 0)))
	(eval-after-load 'company
	  '(progn
	     (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
			 (define-key company-active-map (kbd "<return>") nil)
			 (define-key company-active-map (kbd "RET") nil)
	     ;; (define-key company-active-map (kbd "<tab>") 'company-complete-common)  ; Insert the common part of all candidates.  
	     ;; (define-key company-active-map (kbd "<tab>") 'company-select-next))
		))

	(use-package company-flx
		:ensure t
		:config
		(company-flx-mode +1))

	;; add company to org-mode
 	(add-to-list 'company-backends 'company-capf)
	(defun add-pcomplete-to-capf ()
		(add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
	(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
	)
#+end_src

** Syntax checking

*** flycheck

#+begin_src emacs-lisp
(use-package flycheck
	:ensure t
	:config
	(global-flycheck-mode t)
	(add-hook 'text-mode-hook '(lambda ()(flycheck-mode 0)))
	)
#+end_src

*** flycheck-plantuml

#+BEGIN_SRC emacs-lisp
(use-package flycheck-plantuml
  :ensure t
  :after (flycheck plantuml)
  :config (flycheck-plantuml-setup))
#+END_SRC

** Spell checking

*** flyspell

#+begin_src emacs-lisp
(setq ispell-program-name "C:\\Program Files (x86)\\Aspell\\bin\\aspell.exe")
(global-set-key (kbd "C-<f6>") 'flyspell-toggle)
(global-set-key (kbd "<f6>") 'flyspell-toggle)
(eval-after-load "flyspell"
	'(dolist
			 (define-key flyspell-mode-map (kbd "M-<f6>") 'ispell-word)
		 (define-key flyspell-mode-map (kbd "<f6>") 'flyspell-next-and-ispell-word)
		 (define-key flyspell-mode-map (kbd "S-<f6>") 'flyspell-previous-and-ispell-word)))

;; remove keybindings for autocorrect 
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-;") nil))
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-.") nil))

;; ;; activate for text
;; (dolist (hook '(text-mode-hook LaTeX-mode-hook))
;; 	(add-hook hook (lambda () (flyspell-mode 1))))

(defun flyspell-toggle (arg)
	(interactive "p")
	(if (bound-and-true-p flyspell-mode)
			(progn
				 (flyspell-mode -1)
			)	 
		(progn
			(flyspell-buffer)
			(flyspell-mode)
			)))

;; move point to previous error
;; http://emacs.stackexchange.com/a/14912/2017
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))))))


(defun flyspell-next-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-next-error)
		(ispell-word)
		)
  )

(defun flyspell-previous-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-previous-error)
		(ispell-word)
		)
  )

#+end_src

** Paren handling

*** smartparens

#+begin_src emacs-lisp
	(use-package smartparens
		:ensure t
		:config
		(use-package smartparens-config)
		(setq sp-autoescape-string-quote nil)
		(--each '(css-mode-hook
							js-mode-hook
							java-mode-hook
							perl-mode-hook
              plantuml-mode-hook
							python-mode-hook
							emacs-lisp-mode-hook
							LaTeX-mode-hook
							bibtex-mode-hook
							shell-mode-hook
							sh-mode-hook
							TeX-mode-hook
							markdown-mode-hook
							org-mode-hook)
			(add-hook it #'smartparens-mode))
		(require 'smartparens-latex)
		;; org-mode
		(sp-with-modes 'org-mode
			(sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-before-word-p sp-point-at-bol-p sp-in-math-p) )
			(sp-local-pair "_" "_" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "/" "/" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "~" "~" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "=" "=" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "+" "+" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p tl/sp-point-after-hash-p) )
			(sp-local-pair "$" "$" :unless '(sp-point-after-word-p sp-point-before-word-p) )
			(sp-local-pair "«" "»"))
		)
	(defun tl/sp-point-after-hash-p (id action context)
		"Return t if point is after a hash, nil otherwise.
	This predicate is only tested on \"insert\" action.
	Its definition follows the one of sp-point-after-word-p."
		(when (eq action 'insert)
			(sp--looking-back-p (concat "\\(#\\)" (regexp-quote id)))))

	;; jump to matching paren
	(defun goto-match-paren (arg)
		"Go to the matching  if on (){}[], similar to vi style of % "
		(interactive "p")
		;; first, check for "outside of bracket" positions expected by forward-sexp, etc.
		(cond ((looking-at "[\[\(\{]") (forward-sexp))
					((looking-back "[\]\)\}]" 1) (backward-sexp))
					;; now, try to succeed from inside of a bracket
					((looking-at "[\]\)\}]") (forward-char) (backward-sexp))
					((looking-back "[\[\(\{]" 1) (backward-char) (forward-sexp))
					(t nil)))
	(global-set-key (kbd "C-M-m") 'goto-match-paren)
	(global-set-key (kbd "M-(") 'sp-backward-sexp)
	(global-set-key (kbd "M-)") 'sp-forward-sexp)
	(global-set-key (kbd "M-m") 'goto-match-paren)
	(global-set-key (kbd "M-[") 'sp-beginning-of-sexp)
	(global-set-key (kbd "M-]") 'sp-end-of-sexp)
	(global-set-key (kbd "M-DEL") nil)
	(global-set-key (kbd "M-DEL M-[") 'sp-unwrap-sexp)
#+end_src

*** emacs-pairs

#+begin_src emacs-lisp
;; https://ebzzry.github.io/emacs-pairs.html
;; (defmacro def-pairs (pairs)
;;   `(progn
;;      ,@(loop for (key . val) in pairs
;;           collect
;;             `(defun ,(read (concat
;;                             "wrap-with-"
;;                             (prin1-to-string key)
;;                             "s"))
;;                  (&optional arg)
;;                (interactive "p")
;;                (sp-wrap-with-pair ,val)))))
;; (def-pairs ((paren        . "(")
;;             (bracket      . "[")
;;             (brace        . "{")
;;             (single-quote . "'")
;;             (double-quote . "\"")
;;             (back-quote   . "`")))
;; (global-set-key (kbd "C-[") 'wrap-with-brackets) ; TODO: find nice key bindings
;; (global-set-key (kbd "C-(") 'wrap-with-parens)
;; (global-set-key (kbd "C-{") 'wrap-with-braces)
#+end_src

** Indentation

Auto-indent when yanking
https://www.emacswiki.org/emacs/AutoIndentation

#+begin_src emacs-lisp
(dolist (command '(yank yank-pop))
	(eval `(defadvice ,command (after indent-region activate)
					 (and (not current-prefix-arg)
								(member major-mode '(emacs-lisp-mode lisp-mode
																										 clojure-mode    scheme-mode
																										 haskell-mode    ruby-mode
																										 rspec-mode      python-mode
																										 c-mode          c++-mode
																										 objc-mode       latex-mode
																										 plain-tex-mode))
								(let ((mark-even-if-inactive transient-mark-mode))
									(indent-region (region-beginning) (region-end) nil))))))
#+end_src

** Selection

*** expand-region

#+begin_src emacs-lisp
(use-package expand-region
	:ensure t
	:bind ("C-+" . er/expand-region)
	)
#+end_src

*** Mouse selection

Copy mouse selection to kill-ring:
#+begin_src emacs-lisp
;; (setq mouse-drag-copy-region t)
#+end_src

** Cursor actions

*** ace-jump

#+begin_src emacs-lisp
(use-package ace-jump-mode
	:ensure t
	:bind 
	("C-c SPC" . ace-jump-mode))
#+end_src

*** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
	:ensure t
	:bind
	("C-S-c C-S-c" . mc/edit-lines)
	("C->" . mc/mark-next-like-this)
	("C-<" . mc/mark-previous-like-this)
	("C-c C-<" . mc/mark-all-like-this)
	)
#+end_src

*** point-undo

Cursor position history (LOCAL)

#+begin_src emacs-lisp
(require 'point-undo)
(global-set-key [M-left] 'point-undo)
(global-set-key [M-right] 'point-redo)
(global-set-key (kbd "M-j") 'point-undo)
(global-set-key (kbd "M-k") 'point-redo)
;; focus on line-based jumps
;; http://emacs.stackexchange.com/a/28078/12336
(defvar point-undo-ring-length 100)
(defvar point-undo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-undo-ring)
(defvar point-redo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-redo-ring)
(defun point-undo-pre-command-hook ()
  "Save positions before command."
  (unless (or (eq this-command 'point-undo)
              (eq this-command 'point-redo))
    (let ((line (line-number-at-pos)))
      (when (eq line (cdr (nth 0 (ring-elements point-undo-ring))))
        (ring-remove point-undo-ring 0))
      (ring-insert point-undo-ring (cons (point) line))
      (setq point-redo-ring (make-ring point-undo-ring-length)))))
(add-hook 'pre-command-hook 'point-undo-pre-command-hook)
(defun point-undo-doit (ring1 ring2)
  "ring1, ring2 = {point-undo-ring, point-redo-ring}"
  (condition-case nil
      (progn
        (goto-char (car (nth 0 (ring-elements ring1)))) 
        (ring-insert ring2 (ring-remove ring1 0)))
    (error nil)))
(defun point-undo ()
  "Undo position."
  (interactive)
  (point-undo-doit point-undo-ring point-redo-ring))
(defun point-redo ()
  "Redo position."
  (interactive)
  (when (or (eq last-command 'point-undo)
            (eq last-command 'point-redo))
    (point-undo-doit point-redo-ring point-undo-ring)))
#+end_src

*** goto-last-change

Cursor position undo history:

#+begin_src emacs-lisp
(use-package goto-last-change
	:ensure t
	:bind
	("M-_" . goto-last-change))
#+end_src

*** smarter C-a and C-e

Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

** Images

#+BEGIN_SRC emacs-lisp
(use-package image+
	:ensure t
	:init
	(eval-after-load 'image '(require 'image+))
	:config
	(setq imagex-convert-command "magick")  ; "convert" does not work on Windows machines 
	)
#+END_SRC

** Undo & remove

*** undo-tree

Visualize the undo history.

#+begin_src emacs-lisp
(use-package undo-tree
	:ensure t
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+end_src

*** Remove newlines

http://stackoverflow.com/a/5194503
#+begin_src emacs-lisp
(defun remove-newlines-in-region ()
  "Removes all newlines in the region."
  (interactive)
  (save-restriction
    (narrow-to-region (point) (mark))
    (goto-char (point-min))
    (while (search-forward "\n" nil t) (replace-match " " nil t))))

(defun remove-newline ()
	(save-excursion 
		(search-forward "\n")
		(replace-match " ")))

(defun remove-newlines-or-blank-lines-dwim ()
	(interactive)
	(progn (if (use-region-p)
						 (remove-newlines-in-region)
					 (if (this-line-empty-p)
							 (delete-blank-lines)
						 (remove-newline)
					 ))))

(defun next-line-empty-p ()
  (save-excursion
		(next-line)
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun this-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))
#+end_src

*** Remove extra spaces

Remove extra spaces from line or region (TODO):
#+begin_src emacs-lisp
(defun tl/remove-extra-spaces-dwim ()
	"Remove extra spaces in line or in region."
	(interactive)
	(if (region-active-p)
			(save-restriction
				(narrow-to-region (point) (mark))
				(save-excursion 
					(goto-char (point-min))
					(while (re-search-forward "[ ]+" nil t) (replace-match " " nil t))))
		(save-excursion
			(move-beginning-of-line nil)  					; FIXME: undo doesn't see save-excursion
			(while (re-search-forward "[ ]+" (line-end-position) t)
				(replace-match " "))))
	)
#+end_src

*** Tracking changes

http://emacs-fu.blogspot.de/2009/05/tracking-changes.html
#+begin_src emacs-lisp
	;; higlight changes in documents
	(global-highlight-changes-mode t)
	(setq highlight-changes-visibility-initial-state nil); initially hide
	;; toggle visibility
	;; (global-set-key (kbd "<f8>") 'highlight-changes-visible-mode) ;; changes
	;; remove the change-highlight in region
	;; (global-set-key (kbd "S-<f8>") 'highlight-changes-remove-highlight)
	;; if you're not already using it for something else...
	(global-set-key (kbd "<M-prior>") 'highlight-changes-next-change)
	(global-set-key (kbd "<M-next>")  'highlight-changes-previous-change)
	;; faces
	(set-face-foreground 'highlight-changes nil)
	(set-face-background 'highlight-changes "#916868")
	(set-face-foreground 'highlight-changes-delete nil)
	(set-face-background 'highlight-changes-delete "#916868")

	;; http://stackoverflow.com/a/21084181/6452961
	;; show mark in fringe
	(eval-after-load "hilit-chg"
		'(progn
			 (defvar highlight-fringe-mark 'filled-square
				 "The fringe bitmap name marked at changed line.
	Should be selected from `fringe-bitmaps'.")

			 (defadvice hilit-chg-make-ov (after hilit-chg-add-fringe activate)
				 (mapc (lambda (ov)
								 (if (overlay-get ov 'hilit-chg)
										 (let ((fringe-anchor (make-string 1 ?x)))
											 (put-text-property 0 1 'display
																					(list 'left-fringe highlight-fringe-mark)
																					fringe-anchor)
											 (overlay-put ov 'before-string fringe-anchor))
									 ))
							 (overlays-at (ad-get-arg 1))))))
	;; remove highlights on save time
	(add-hook 'after-save-hook
						(lambda ()
							(when highlight-changes-mode
								(save-restriction
									(widen)
									(highlight-changes-remove-highlight (point-min) (point-max))))))
#+end_src

** Switch between buffers

Switching between buffers with C-tab:
#+begin_src emacs-lisp
  (use-package iflipb
    :ensure t
    :config
    (setq iflipb-wrap-around t)
    (setq iflipb-ignore-buffers "^ ")     ; include all buffers
    :bind
    ("<C-tab>" . iflipb-next-buffer))
#+end_src

** Narrowing

http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
"Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
(interactive "P")
(declare (interactive-only))
(cond ((and (buffer-narrowed-p) (not p)) (widen))
			((region-active-p)
			 (narrow-to-region (region-beginning)
												 (region-end)))
			((derived-mode-p 'org-mode)
			 ;; `org-edit-src-code' is not a real narrowing
			 ;; command. Remove this first conditional if
			 ;; you don't want it.
			 (cond ((ignore-errors (org-edit-src-code) t)
							(delete-other-windows))
						 ((ignore-errors (org-narrow-to-block) t))
						 (t (org-narrow-to-subtree))))
			((derived-mode-p 'latex-mode)
			 (LaTeX-narrow-to-environment))
			(t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only
;; copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (define-key LaTeX-mode-map "\C-xn"
              nil)))
#+end_src

** File browser
*** ranger, deer

Use deer instead plain directory listing:
#+begin_src emacs-lisp
(use-package ranger
	:ensure t
	:bind
	("C-x C-d" . deer))

;; open file from inside a buffer
(global-set-key (kbd "C-x f") 'find-file-at-point)
#+end_src

** Commenting

#+begin_src emacs-lisp
(global-set-key (kbd "C-;") 'comment-or-uncomment-region-or-line)
(eval-after-load "LaTeX-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(eval-after-load "markdown-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
				(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)
    (next-line)))
#+end_src

*** Critical markup

#+begin_src emacs-lisp
(use-package cm-mode
	:ensure t
	:config
	(setq-default cm-author user-acronym))
#+end_src

** Line actions
*** Delete line
#+begin_src emacs-lisp
;; (global-set-key (kbd "C-d C-o") 'delete-blank-lines) ; not allowed here, see underi-mode.el
;; (global-set-key (kbd "C-d C-m") 'delete-blank-lines)
(global-set-key (kbd "C-S-k") 'kill-whole-line)
;; (global-set-key (kbd "C-k") 'kill-sentence) ; too greedy
(global-set-key (kbd "C-S-d") 'kill-whole-line)
#+end_src

Copy/cut whole line or region:
#+begin_src emacs-lisp
(global-set-key (kbd "C-w") 'xah-cut-line-or-region) ; cut
(global-set-key (kbd "M-w") 'xah-copy-line-or-region) ; copy
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))
(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2016-06-18"
  (interactive)
  (let (-p1 -p2)
    (if current-prefix-arg
        (setq -p1 (point-min) -p2 (point-max))
      (if (use-region-p)
          (setq -p1 (region-beginning) -p2 (region-end))
        (setq -p1 (line-beginning-position) -p2 (line-end-position))))
    (if (eq last-command this-command)
        (progn
          (progn ; hack. exit if there's no more next line
            (end-of-line)
            (forward-char)
            (backward-char))
          ;; (push-mark (point) "NOMSG" "ACTIVATE")
          (kill-append "\n" nil)
          (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
          (message "Line copy appended"))
      (progn
        (kill-ring-save -p1 -p2)
        (if current-prefix-arg
            (message "Buffer text copied")
          (message "Text copied"))))
		;; TL: commented out the following two lines. Cursor remains at region.
    ;; (end-of-line)   
    ;; (forward-char)
    ))
#+end_src

*** New line

#+begin_src emacs-lisp
(global-set-key (kbd "S-<return>") 'smart-open-line)
(global-set-key (kbd "C-x C-<return>") 'smart-open-line)
(global-set-key (kbd "C-S-<return>") 'smart-open-line-above)
(global-set-key (kbd "C-o") 'smart-open-line)
(global-set-key (kbd "C-S-o") 'smart-open-line-above)
;; http://emacsredux.com/blog/2013/03/26/smarter-open-line/
(defun smart-open-line ()
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
;; http://emacsredux.com/blog/2013/06/15/open-line-above/
(defun smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
#+end_src

*** Center line
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-l") 'recenter-top-bottom)
#+end_src

** Capitalization

Toggle letter case:
 #+begin_src emacs-lisp
(global-set-key (kbd "C-9") 'xah-toggle-letter-case) 
(defun xah-toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.

URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
Version 2016-01-08"
  (interactive)
  (let (
        (deactivate-mark nil)
        -p1 -p2)
    (if (use-region-p)
        (setq -p1 (region-beginning)
              -p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alnum:]")
        (setq -p1 (point))
        (skip-chars-forward "[:alnum:]")
        (setq -p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region -p1 -p2)
      (put this-command 'state 1))
     ((equal 1  (get this-command 'state))
      (upcase-region -p1 -p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region -p1 -p2)
      (put this-command 'state 0)))))
#+end_src

** Buffer actions

Open untitled new buffer:
#+begin_src emacs-lisp
(defun xah-new-empty-buffer ()
  "Open a new empty buffer.
URL `http://ergoemacs.org/emacs/emacs_new_empty_buffer.html'
Version 2015-06-12"
  (interactive)
  (let ((buf (generate-new-buffer "untitled")))
    (switch-to-buffer buf)
    (funcall (and initial-major-mode))
    (setq buffer-offer-save t)))
(global-set-key (kbd "<f7> <f7>") 'xah-new-empty-buffer)
#+end_src

Kill buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "M-<f4>") 'kill-this-buffer)
 #+end_src
 
Revert buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'revert-buffer)
 #+END_SRC

* underi-mode

Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 

Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html

#+BEGIN_SRC emacs-lisp
	(define-minor-mode underi-mode
		"Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 
	Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html"
		:lighter " ui"
		;; :global "t"
		:init-value t
		:keymap (let ((map (make-keymap)))

							(define-key input-decode-map (kbd "C-i") (kbd "H-i")) ; to disentangle <tab> and C-i

							;; cursor keys
							(define-key key-translation-map (kbd "M-i") (kbd "<up>"))
							(define-key key-translation-map (kbd "M-k") (kbd "<down>"))
							(define-key key-translation-map (kbd "M-j") (kbd "<left>"))		
							(define-key key-translation-map (kbd "M-l") (kbd "<right>"))
							(define-key key-translation-map (kbd "M-I") (kbd "S-<up>"))
							(define-key key-translation-map (kbd "M-K") (kbd "S-<down>"))
							(define-key key-translation-map (kbd "M-J") (kbd "S-<left>"))		
							(define-key key-translation-map (kbd "M-L") (kbd "S-<right>"))

							;; more cursor keys
							(define-key map (kbd "M-n") 'scroll-up-command)
							(define-key map (kbd "M-p") 'scroll-down-command)
							(define-key map (kbd "M-o") 'point-redo)
							(define-key map (kbd "M-u") 'point-undo)
							(define-key map (kbd "M-z") 'goto-last-change)
							(define-key map (kbd "C-M-i") 'backward-paragraph)
							(define-key map (kbd "C-M-k") 'forward-paragraph)
							(define-key map (kbd "C-M-j") 'left-word)
							(define-key map (kbd "C-M-l") 'right-word)

							(define-key map (kbd "M-s-j")  'windmove-left)
							(define-key map (kbd "M-s-l") 'windmove-right)
							(define-key map (kbd "M-s-i")   'windmove-up)
							(define-key map (kbd "M-s-k")  'windmove-down)

							(define-key key-translation-map (kbd "C-n") (kbd "C-c C-n"))
							(define-key key-translation-map (kbd "C-p") (kbd "C-c C-p"))

							;; delete 
							(define-key map (kbd "C-d") nil)
							(define-key map (kbd "C-d C-k") 'kill-line)
							(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d <left>") 'delete-backward-char)
							(define-key map (kbd "C-d <right>") 'delete-forward-char)
							(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
							(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
							(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-o") 'delete-blank-lines)
							(define-key map (kbd "C-d C-m") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-<return>") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
							(define-key map (kbd "C-d C-e") 'kill-line)
							(define-key map (kbd "C-S-d") 'kill-whole-line)
							(define-key map (kbd "C-d SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d C-SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d )") 'sp-unwrap-sexp)

							;; return
							(define-key input-decode-map (kbd "C-m") (kbd "H-o")) ; to disentangle <return> and C-m
							(define-key key-translation-map (kbd "H-o") (kbd "RET"))
							(define-key map (kbd "C-S-m") 'smart-open-line)

 							;; org-babel
							(define-key org-mode-map (kbd "C-d r") 'org-babel-remove-result)

							;; miscellaneous actions
							(define-key map (kbd "C-j") 'ace-jump-mode)
							(define-key map (kbd "H-i") 'helm-imenu)
							(define-key map (kbd "C-S-i") 'imenu-list)

							map
							)
		(add-hook 'minibuffer-setup-hook 'underi-minibuffer)
		(with-eval-after-load 'org
			(define-key org-mode-map (kbd "C-d c") 'org-table-delete-column )
			(define-key org-mode-map (kbd "C-d C-c") 'org-table-delete-column )
			)																	

	)	
	;; TODO: make C-d switch to delete-mode?
	;; http://stackoverflow.com/a/12010437/6452961

	(defun tl/kill-forward-line (N)
		(interactive)
		(save-excursion
			(when (= (forward-line N) 0)
				(kill-whole-line))))

	(defun underi-minibuffer ()
		"Keymap for the minibuffer."
		(let ((map minibuffer-local-map))

			;; move cursor
			(define-key map (kbd "M-n") 'scroll-up-command)
			(define-key map (kbd "M-p") 'scroll-down-command)
			(define-key map (kbd "M-o") 'point-redo)
			(define-key map (kbd "M-u") 'point-undo)
			(define-key map (kbd "M-z") 'goto-last-change)
			(define-key map (kbd "C-M-i") 'backward-paragraph)
			(define-key map (kbd "C-M-k") 'forward-paragraph)
			(define-key map (kbd "C-M-j") 'left-word)
			(define-key map (kbd "C-M-l") 'right-word)

			;; delete 
			(define-key map (kbd "C-d") nil)
			(define-key map (kbd "C-d C-k") 'kill-line)
			(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d <left>") 'delete-backward-char)
			(define-key map (kbd "C-d <right>") 'delete-forward-char)
			(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
			(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
			(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
			(define-key map (kbd "C-S-d") 'kill-whole-line)
			(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d )") 'sp-unwrap-sexp)
			))

	(define-key helm-map (kbd "H-i") 'helm-select-action) ; show actions (default is <tab>)

	;; (add-hook 'text-mode-hook 'underi-mode) ; superseded by :init-value t
	;; (add-hook 'prog-mode-hook 'underi-mode) ; superseded by :init-value t
#+END_SRC

* winkeys-mode

Key bindings roughly following the conventions of the Windows habitat.

#+BEGIN_SRC emacs-lisp
(define-minor-mode winkeys-mode
	"Key bindings roughly following the conventions of the Windows habitat."
	:lighter " wk"
	;; :global "t"
	:init-value t
	:keymap (let ((map (make-keymap)))
						
						;; save
						(define-key map (kbd "C-s") 'save-buffer)
						(define-key map (kbd "C-S-s") 'write-file)

						;; search and replace
						(define-key map (kbd "C-f") 'helm-swoop)
						(define-key map (kbd "C-S-f a") 'helm-multi-swoop-all)
						(define-key map (kbd "C-S-f m") 'helm-multi-swoop-current-mode)
						;; (define-key map (kbd "C-f") 'isearch-search)
						(define-key map (kbd "C-r") 'query-replace)
						(define-key map (kbd "C-S-r") 'query-replace-regexp)
						(define-key map (kbd "C-o") 'helm-find-files)

						;; mark all
						(define-key map (kbd "C-x C-a") 'mark-whole-buffer)
						
						;; quit
						(define-key key-translation-map (kbd "M-q") (kbd "C-g"))

						;; undo/redo
						(define-key map (kbd "C-z") 'undo-tree-undo)
						(define-key map (kbd "C-S-z") 'undo-tree-redo)

						;; press ESC only once
						(define-key map (kbd "<escape>") 'keyboard-escape-quit)
										
						map
						)
	(add-hook 'minibuffer-setup-hook 'winkeys-minibuffer)
	(add-hook 'org-src-mode-hook
						(lambda ()((define-key (kbd "C-s") 'org-edit-src-save))))
	)

(defun winkeys-minibuffer ()
	"Keymap for the minibuffer."
	(let ((map minibuffer-local-map))

		;; undo/redo
		(define-key map (kbd "C-z") 'undo-tree-undo)
		(define-key map (kbd "C-S-z") 'undo-tree-redo)
		
		))

#+END_SRC
 
** TODO How to make this a proper part of the mode, i.e., how to disable this when disabeling the mode?

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm-swoop
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-f") 'tl/helm-swoop-C-s) 
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-f") 'helm-next-line)
	(define-key helm-swoop-map (kbd "C-S-f a") 'helm-multi-swoop-all-from-helm-swoop)
	(define-key helm-swoop-map (kbd "C-S-f m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	(define-key helm-swoop-map (kbd "M-a") 'helm-multi-swoop-all-from-helm-swoop))

;; Let helm-swoop behave more like isearch
(defun tl/helm-swoop-C-s ()
	(interactive)
	(if (boundp 'helm-swoop-pattern)
			(if (equal helm-swoop-pattern "")
					(previous-history-element 1)
				(helm-next-line))
		(helm-next-line)
		))
#+END_SRC

* sr-speedbar

#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
	:ensure t
	:bind
	("C-c C-k C-b" . sr-speedbar-toggle)
	:config
	(setq sr-speedbar-right-side nil)                          ; always on left side
	(add-hook 'speedbar-mode-hook '(lambda () (linum-mode 0))) ; disable linum for speedbar
	(setq speedbar-show-unknown-files t)                       ; show all files
	(setq sr-speedbar-width 30)                                ; default width
	)
#+END_SRC

* Windows and frames

Better keys for switching between windows:
#+BEGIN_SRC emacs-lisp
	;; (when (fboundp 'windmove-default-keybindings)
	;; (windmove-default-keybindings))
	(global-set-key (kbd "M-s-<left>")  'windmove-left)
	(global-set-key (kbd "M-s-<right>") 'windmove-right)
	(global-set-key (kbd "M-s-<up>")   'windmove-up)
	(global-set-key (kbd "M-s-<down>")  'windmove-down)

	;; (global-set-key (kbd "<f2> <left>")  'windmove-left)
	;; (global-set-key (kbd "<f2> <right>") 'windmove-right)
	;; (global-set-key (kbd "<f2> <up>")   'windmove-up)
	;; (global-set-key (kbd "<f2> <down>")  'windmove-down)

	;; clone frame
	;; (global-set-key (kbd "<f2> <f2>") 'make-frame)

	;; split window
	;; (global-set-key (kbd "<f2> v") 'split-window-vertically)
	;; (global-set-key (kbd "<f2> h") 'split-window-horizontally)
	;; (global-set-key (kbd "<f2> b") 'split-window-below)
	;; (global-set-key (kbd "<f2> r") 'split-window-right)

	;; close window
	(global-set-key (kbd "M-<f2>") 'delete-window)

	;; winner mode:
	(winner-mode 1)
	;; (global-set-key (kbd "<f2> z") 'winner-undo) ; undo pane configuration
	;; (global-set-key (kbd "<f2> Z") 'winner-redo) ; redo pane configuration
#+END_SRC

** COMMENT golden-ratio

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :init
  (golden-ratio-mode 1))
#+END_SRC

* Git

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
	:ensure t
	:bind
	("C-x g" . magit-status)
	;; ("C-x C-g" . magit-status)
	:config
	;; show magit full screen
	(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
	)
#+end_src

** magithub

Enhancement of magit to make available a more comprehensive access to Github repositories, regrading issues etc.:

#+BEGIN_SRC emacs-lisp
(use-package magithub
	:ensure t
  :after magit
  :config (magithub-feature-autoinject t))
#+END_SRC

** git-gutter

#+begin_src emacs-lisp
(use-package git-gutter
	:ensure t
	:config
	(global-git-gutter-mode +1)
	;; (git-gutter:linum-setup) ; git-gutter is struggling with linum-mode
	(custom-set-variables
	 '(git-gutter:update-interval 2))
	:bind
	("C-x C-g" . nil)
	("C-x C-g TAB" . git-gutter:popup-hunk)
	("C-x C-g _" . git-gutter:revert-hunk)
	("C-x C-g z" . git-gutter:revert-hunk)
	("C-x C-g C-g" . git-gutter-mode)
	("C-x C-g g" . git-gutter-mode)
	("C-x C-g n" . git-gutter:next-hunk)
	("C-x C-g p" . git-gutter:previous-hunk)
	)
#+END_SRC

* Shells

** better-shell

#+BEGIN_SRC emacs-lisp
(use-package better-shell
    :ensure t
    ;; :bind (("C-'" . better-shell-shell)
    ;;        ("C-;" . better-shell-remote-open))
		)
#+END_SRC

** Windows powershell

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
		(use-package powershell
			:ensure t)
)
(put 'upcase-region 'disabled nil)
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
					'(lambda () (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
(setq eshell-cmpl-dir-ignore "\`\\(CVS\\)/\\'") ; in order to complete `..` to `../`
(defun tl/eshell ()										; http://emacs.stackexchange.com/a/28603/12336
  (interactive)
  (eshell t))
(global-set-key (kbd "<f7> e") 'tl/eshell)
 #+END_SRC

* bbdb

http://sachachua.com/notebook/emacs/bbdb-config.el

#+BEGIN_SRC emacs-lisp
  (use-package bbdb
    :ensure t
    :config (progn
              (bbdb-initialize)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-message)
                                          ;(add-hook 'message-setup-hook 'bbdb-define-all-aliases)

              (setq bbdb-file "~/Dropbox/bbdb"
                    bbdb-auto-revert t
                    bbdb-check-auto-save-file t
                    bbdb-expand-mail-aliases t
                    bbdb-phone-style nil
                    ;; bbdb-pop-up-window-size 10
                    bbdb-pop-up-target-lines 1 ; The window should be as small as possible
                    bbdb-use-pop-up nil        ; Show pup-up?

                                          ;bbdb/news-auto-create-p t
                    bbdb-complete-name-allow-cycling t
                    bbdb-complete-mail-allow-cycling t
                    bbdb-complete-name-full-completion t
                    bbdb-completion-type 'primary-or-name
                                          ;bbdb-use-pop-up nil

                    bbdb-offer-save 1  ; Always save
                    bbdb-electric-p t)
              ))

  (use-package bbdb-vcard
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-bbdb
    :ensure t)
  (global-set-key (kbd "<f7> a") 'helm-bbdb)
#+END_SRC

* tramp

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (if (eq system-type 'windows-nt) 
      (setq tramp-default-method "plink")
    (setq tramp-default-method "ssh"))
  (setq tramp-default-user "lichte")
#+END_SRC

* hydra

** hydra: begin

#+BEGIN_SRC emacs-lisp
	(use-package hydra
		:ensure t
		:config

#+END_SRC

** hydra-f1

See also https://www.reddit.com/r/emacs/comments/3ba645/does_anybody_have_any_real_cool_hydras_to_share/cspqaly/

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f1 (:exit t :hint nil)

    "
    ╭────┐      
    │<f1>│  _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
    │Help│  Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭╯    └──^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^────╯

    Describe      ^^Keys                     ^^Elisp           ^^Documentation
    --------------^^-------------------------^^----------------^^---------------
    _m_ode          single _k_eybinding        _a_propros        _i_nfo
    _p_ackage       available _b_indings       _f_unction        _d_ocsets
    _c_ursor        _w_here is key             _v_ariable        _n_: man

  "
    ;; Boring help commands...
    ("e" view-echo-area-messages "messages")
    ("l" view-lossage "lossage")
    ("C" describe-coding-system "coding system")
    ("I" describe-input-method "input method")

    ;; Documentation
    ("i" info nil)
    ("n" helm-man-woman nil)
    ("d" helm-dash nil)

    ;; Keybinds
    ("b" describe-bindings nil)
    ("c" describe-key-briefly nil)
    ("k" describe-key nil)
    ("w" where-is nil)

    ;; Elisp
    ("a" apropos-command nil)
    ("s" info-lookup-symbol nil)
    ("v" describe-variable nil)
    ("f" describe-function nil)
    ("y" describe-syntax nil)

    ;; Describe
    ("p" describe-package nil)
    ("m" describe-mode nil)
		("c" (what-cursor-position t) nil)

		("<f2>" hydra-f2/body :exit t)
		("<f3>" hydra-f3/body :exit t)
		("<f4>" hydra-f4/body :exit t)
		("<f5>" revert-buffer :exit t)
		("<f6>" hydra-f6/body :exit t)
		("<f7>" hydra-f7/body :exit t)
		("<f8>" hydra-f8/body :exit t)
		("<f9>" hydra-f9/body :exit t)
    ;; quit
    ("q" help-quit "quit"))

(global-set-key (kbd "<f1>") #'hydra-f1/body)
#+END_SRC

** hydra-f2

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f2
		(:hint nil
					 :idle 0.2)
	"
         ^^  ╭──────┐       
     _<f1>_  │<f2>  │  _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^  │Window│  Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^──╯      └────────^^────────^^──────────^^───^^───────^^───────^^───────^^────╯

          ^^  _<up>_               │      ^^                    [_z_] window undo
          ^^   ↑   ^^              │split [_h_]orizontally      [_Z_] window redo
    _<left>_ ←   → _<right>_       │      ^^                    [_n_] new frame
          ^^   ↓   ^^             ────────^^─────────────              
          ^^ _<down>_              split [_v_]ertically             [_q_]uit    
	"
	("<down>" windmove-down :exit t)
	("<up>" windmove-up :exit t)
	("<right>" windmove-right :exit t)
	("<left>" windmove-left :exit t)
	("n" make-frame :exit t)
	("v" split-window-vertically :exit t)
	("h" split-window-horizontally :exit t)
	("z" winner-undo)
	("Z" winner-redo)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f2>") 'hydra-f2/body)
#+END_SRC

** hydra-f3

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f3
		(:hint nil
					 :idle 0.2)
	"

         ^^   ^^         ╭──────┐       
     _<f1>_    _<f2>_    │<f3>  │  _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^    Window^^  │Config│  Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^───╯      └───────^^──────────^^───^^───────^^───────^^───────^^────╯
 
         [_i_] init file           [_p_] package manager      [_m_] macros
         [_d_] .emacs.d            [_u_] upgrade packages
         [_c_] customize emacs                                [_q_]uit
	"
	("i" (find-file (expand-file-name org-init-file user-emacs-directory)) :exit t)
	("d" (find-file user-emacs-directory) :exit t)
	("c" customize :exit t)
	("p" paradox-list-packages :exit t)
	("u" paradox-upgrade-packages :exit t)
	("m" hydra-macro/body :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f3>") 'hydra-f3/body)
#+END_SRC

** hydra-f4

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f4
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^  ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_    │<f4> │  _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^  │Check│  Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^──╯     └─────────^^───^^───────^^───────^^───────^^─────╯
 
      [_e_] compilation errors      [_c_] code checking     [_s_] spell checking 
         ^^         ^^         ^^                  ^^   ^^       ^^       ^^    [_q_]uit
	"
	("e" hydra-compilation-error/body :exit t)
	("c" hydra-flycheck/body :exit t)
	("s" hydra-flyspell/body :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f4>") 'hydra-f4/body)

#+END_SRC

** hydra-f6

#+BEGIN_SRC 
(defvar hydra-f6-menu
	"
         ^^         ^^         ^^       ^^        ^^     ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_     │<f6>│  _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^  │Mode│  Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^──╯    └────^^─────────^^──────^^─╯
 
    ^^ _<f6>_: hydra for major mode ^^ ^^ ^^ ^^ ^^ ^^                         [_q_]uit
	"
)

	(defhydra hydra-f6-old
		(:hint nil
					 :idle 0.2)
(concat hydra-f6-menu) 
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-for-major-mode :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f6>") 'hydra-f6/body)

(defun hydra-f6/body () ;hydra-for-major-mode ()
	(interactive)
  (if (string-equal (buffer-mode) "dired-mode")
		(hydra-dired-main/body)
    (if (string-equal (buffer-mode) "image-mode")
				(hydra-image/body)
			(if (string-equal (buffer-mode) "org-mode")
					(hydra-org-main/body)
				(message (concat "no hydra defined for major mode")))))
)
#+END_SRC

Function to look up the major mode of a buffer:
#+BEGIN_SRC emacs-lisp
(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
											(if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+END_SRC

** hydra-f7

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f7
	(:hint nil
				 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_  │<f7>│  _<f8>_  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^  │Open│  Mark^^  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^──╯    └──────^^────────╯
 
       [_a_] adress book        [_d_] dired/file browser     [_t_] pomodoro timer
       [_b_] new buffer         [_e_] emacs shell  
       [_i_] buffer overview    [_s_] system shell
       [_c_] calendar           [_m_] magit status           [_q_]uit
	" 
	("a" helm-bbdb :exit t)
	("c" my-open-calfw :exit t)
	("d" dired-jump :exit t)
	("s" shell :exit t)
	("b" xah-new-empty-buffer :exit t)
	("i" ibuffer :exit t)
	("m" magit-status :exit t)
	("e" tl/eshell :exit t)
	("t" tomatinho :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f7>") 'hydra-f7/body)
#+END_SRC

** hydra-f8

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f8
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^      ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_  │<f8> │  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^  │Mark │  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^──╯     └─────^^─╯
 
        [_c_] highlight changes        [_w_] show/hide whitespaces
        [_g_] git gutter               [_*_] critic markup          
        [_s_] highlight same symbols   [_r_] mark rectangular                    [_q_]uit
	"
	("g" hydra-git-gutter/body :exit t)
	("c" hydra-highlight-changes/body :exit t)
	("r" rectangle-mark-mode :exit t)
	("s" hydra-highlight-symbol/body :exit t)
	("w" whitespace-mode :exit t)
  ("*" hydra-cm-mode/body :exit t )
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
	(global-set-key (kbd "<f8>") 'hydra-f8/body)
#+END_SRC

** hydra-f9

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f9
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^       ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_  │<f9>│ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^  │Org │
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^──╯    ╵
 
     ^^  [_a_] agenda  ^^    [_n_] notes   ^^  ^^   ^^  ^^  ^^   [_r_] reload org       	
     ^^  [_d_] deft    ^^    [_t_] todos   ^^  ^^   ^^  ^^  ^^   [_u_] update agenda files
     ^^  [_c_] capture ^^    [_w_] work in progress ^^  ^^  ^^  ^^ ^^        
     ^^  [_f_] search  ^^                ^^  ^^  ^^  ^^  ^^                      [_q_]uit

	"
	("a" org-agenda-list :exit t)
	("d" deft :exit t)
	("n" (lambda nil (interactive)
				 (find-file (concat org-notes-dir "/notes.org"))) :exit t)
	("o" deft :exit t)
	("c" org-capture :exit t)
	("t" org-todo-list :exit t)
	("w" (lambda nil (interactive)
				 (find-file (concat org-notes-dir "/work/wip.org"))) :exit t)
	("r" org-reload :exit t)
	("f" org-search-view :exit t)
	("s" org-search-view :exit t)
	("u" tl/update-org-agenda-files :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)

)
	(global-set-key (kbd "<f9>") 'hydra-f9/body)

#+END_SRC

** hydra-cm-mode

#+BEGIN_SRC emacs-lisp
(defhydra hydra-cm-mode
	(:body-pre (when (not (string-equal cm-mode "t"))
							 (font-lock-mode -1)
							 (font-lock-mode 1)
							 (cm-mode 1))
						 :hint nil)
			"
     CriticMarkup
   ╭──────────────╯
      [_<up>_] previous      [_a_] addition         [_i_] accept/reject
    [_<down>_] next          [_d_] deletion         [_I_] accept/reject all
     ^^                      [_s_] substitution
     [_F_] follow changes    [_c_] comment          [_q_]uit													
		 ^^											 ^^							  			[_Q_]uit and deactivate cm-mode
"
			("<up>" #'cm-backward-change)
			("<down>" #'cm-forward-change)
			("a" #'cm-addition)
			("d" #'cm-deletion)
			("s" #'cm-substitution)
			("c"#'cm-comment)
			("i" #'cm-accept/reject-change-at-point)
			("I" #'cm-accept/reject-all-changes)
			("t" #'cm-set-author)
			("F" #'cm-follow-changes)
			("q" nil :color blue)
			("Q" (cm-mode -1) :color blue))
#+END_SRC

** hydra-dired

https://gitlab.com/xuhdev/dired-quick-sort

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dired-main (:hint nil)
"
 ^Navigation^            ^^            ^Mark^              ^Actions^             ^View^
-^----------^------------^^------------^----^--------------^-------^-------------^----^------------

             _<up>_      ^^             _m_: mark           _+_: new						  _g_: refresh              
  ^^            ʌ        ^^             _u_: unmark         _C_: copy to          _/_: filter 
  ^^                     ^^             _U_: unmark all     _D_: delete           _s_: sort		 
  _<left>_  ..     view  _<right>_      _t_: toggle mark    _R_: move to          _(_: details
  ^^               enter _RET_          _*_: specific       ^^                    
  ^^                     ^^             ^^                  _P_: change property
  ^^            v        ^^             ^^                  _Z_: compress				
            _<down>_     ^^             ^^                  _=_: diff             
  ^^                     ^^             ^^                  ^^                    _q_: quit dired     
   _._: home  _j_: jump  _f_: find                          ^^                    _Q_: quit hydra
                                                    
-^----------^------------------------^----^---------------^-------^-------------^----^-----------
"

("<left>" (lambda () (interactive) (find-alternate-file "..")))
("<up>" diredp-previous-line)
("<down>" diredp-next-line)
("RET" dired-find-file)
("<right>" dired-view-file)
("+" hydra-dired-new/body :color blue)
("*" hydra-dired-mark/body :color blue)
("P" hydra-dired-properties/body :color blue)
("O" dired-do-chown)
("M" dired-do-chmod)
("G" dired-do-chgrp)
("C" dired-do-copy)
("D" dired-do-delete)
("R" dired-do-rename)
("S" dired-do-symlink)
("Z" dired-do-compress)
("/" dired-narrow)
("(" dired-hide-details-mode)
("f" my-find-name-dired)
("." (find-file home-directory))
;; ("=" diredp-ediff)  ; FIXME: does not work under windows; does not find diff 
("=" dired-diff)
("g" revert-buffer)
("j" dired-goto-file)
("s" dired-sort-toggle-or-edit)
("m" dired-mark)
("u" dired-unmark)
("U" dired-unmark-all-marks)
("t" dired-toggle-marks)
("v" dired-view-file)
("q" quit-window :color blue)
("Q" nil :color blue)
)

(defhydra hydra-dired-new (:hint nil )
	"New"
	("d" dired-create-directory "directory"  :exit t :after-exit (hydra-dired-main/body))
	("f" find-file "file" :exit t)
	("s" dired-do-symlink "symbolic link" :exit t :after-exit (hydra-dired-main/body))
	("h" dired-do-hardlink "hard link" :exit t :after-exit (hydra-dired-main/body))
	("q" hydra-dired-main/body "quit" :color blue)
	)

(defhydra hydra-dired-mark (:hint nil :after-exit (hydra-dired-main/body))
"Mark"
	("a" (dired-mark-files-regexp ".*") "all" :exit t)
	("d" dired-mark-directories "directories" :exit t)
	("." diredp-mark/unmark-extension "by extension" :exit t)
	("s" dired-mark-symlinks "symbolic links" :exit t)
	("r" dired-mark-files-regexp "by regexp" :exit t)
	("/" dired-mark-sexp "by search term" :exit t)
	("q" hydra-dired-main/body "quit" :exit t)
	)

(defhydra hydra-dired-properties (:hint nil :after-exit (hydra-dired-main/body))
"Change"
	("o" dired-do-chown "owner")
	("r" dired-do-chmod "rights")
	("g" dired-do-chgrp "group")
	("q" hydra-dired-main/body "quit" :color blue)
	)
#+END_SRC

Don't ask for the path when searching for files:
#+BEGIN_SRC emacs-lisp
(defun my-find-name-dired (pattern)
  "My version of find-name-dired that always starts in my chosen folder"
  (interactive "sFind Name (file name wildcard): ")
  (dired-hide-details-mode)
  (find-name-dired "." pattern))
#+END_SRC

** hydra-org

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-main (:hint nil)
"Org-mode"
("a" org-toggle-archive-tag "archive here" :exit t)
("A" org-archive-subtree-default "archive outside" :exit t)
("c" hydra-org-columns/body "columns" :exit t)
("q" nil :color blue)
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-columns (:hint nil :color pink :body-pre (org-columns))
"Org-mode columns"
(">" org-columns-widen "widen")
("<" org-columns-narrow "narrow")
("a" org-columns-edit-allowed "allowed values" :exit t)
("c" org-columns-content "content" :exit t)
("e" org-columns-edit-value "edit" :exit t)
("n" org-columns-next-allowed-value "next allowed value")
("p" org-columns-previous-allowed-value "previous allowed value")
("r" org-columns-redo "refresh")
("s" org-columns-edit-attributes "select attribute")
("t" org-columns-todo "todo")
("M-S-<left>" org-columns-delete "delete")
("M-S-<right>" org-columns-new "new")
("M-<right>" org-columns-move-right "move right")
("M-<left>" org-columns-move-left "move left")
("<delete>" org-columns-delete)
("v" org-columns-show-value "show value")
("q" org-columns-quit :color blue)
)
#+END_SRC

** hydra-git-gutter

#+BEGIN_SRC emacs-lisp

		;; inspired by https://github.com/abo-abo/hydra/wiki/Git-gutter
		(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
																					:hint nil)
			"
     Git gutter
   ╭────────────╯
    [_j_] next hunk        [_s_]tage hunk     [_q_]uit
    [_k_] previous hunk    [_r_]evert hunk    [_Q_]uit and deactivate git-gutter
     ^ ^                   [_p_]opup hunk
    [_h_] first hunk
    [_l_] last hunk        set start [_R_]evision
	"
			("j" git-gutter:next-hunk)
			("k" git-gutter:previous-hunk)
			("h" (progn (goto-char (point-min))
									(git-gutter:next-hunk 1)))
			("l" (progn (goto-char (point-min))
									(git-gutter:previous-hunk 1)))
			("s" git-gutter:stage-hunk)
			("r" git-gutter:revert-hunk)
			("p" git-gutter:popup-hunk)
			("R" git-gutter:set-start-revision)
			("q" nil :color blue)
			("Q" (progn (git-gutter-mode -1)
									;; git-gutter-fringe doesn't seem to
									;; clear the markup right away
									(sit-for 0.1)
									(git-gutter:clear))
			 :color blue))
#+END_SRC

** hydra-ibuffer

Adapted hydra from https://github.com/abo-abo/hydra/wiki/Ibuffer:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^      ^Mark^          ^Actions^          ^View^
-^----------^------^----^----------^-------^----------^----^-------
   _<up>_:   ʌ     _m_: mark       _D_: delete        _g_: refresh
    _RET_: visit   _u_: unmark     _S_: save          _s_: sort
 _<down>_:   v     _*_: specific   _a_: all actions   _/_: filter
-^----------^---^----^----------^-------^----------^----^----------
"
  ("j" ibuffer-forward-line)
  ("<down>" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("<up>" ibuffer-backward-line)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" ibuffer-quit "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC

Automatically open the hydra with ibuffer:

#+BEGIN_SRC emacs-lisp
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
#+END_SRC

** hydra-image

#+BEGIN_SRC emacs-lisp
(defhydra hydra-image ()
	"Manipulate image"
	("+" imagex-sticky-zoom-in "zoom in")
	("-" imagex-sticky-zoom-out "zoom out")
	("m" imagex-sticky-maximize "maximize")
	("o" imagex-sticky-restore-original "original")
	;; ("S" imagex-sticky-save-image "save")
	("r" imagex-sticky-rotate-right "rotate right")
	("l" imagex-sticky-rotate-left "rotate left"))

#+END_SRC

#+RESULTS:
: hydra-image/body

** TODO hydra-latex

- fonts
- jumping
- reftex
- deletion of temporary files
- show log
- show pdf

** hydra-flycheck

#+BEGIN_SRC emacs-lisp
		;; inspired by https://github.com/abo-abo/hydra/wiki/Flycheck
		(defhydra hydra-flycheck
			(:pre (progn (setq hydra-lv t) (flycheck-mode +1) (flycheck-list-errors))
						:post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
						:hint nil)
"
  Errors
╭────────╯
"
			("f"  flycheck-error-list-set-filter                            "Filter")
			("j"  flycheck-next-error                                       "Next")
			("k"  flycheck-previous-error                                   "Previous")
			("gg" flycheck-first-error                                      "First")
			("G"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
			("Q"  (flycheck-mode -1) "Quit flycheck-mode") 
			("q"  nil))
#+END_SRC

** hydra-compilation-error

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/Compilation
(defhydra hydra-compilation-error (:hint nil :body-pre (hydra-compilation-error-body-pre))
	"
	    Compilation errors
    ╭────────────────────╯
	      [_<up>_] previous error   [_l_] list errors    [_q_]uit
	    [_<down>_] next error       
	"
	("`" hydra-compilation-error-next)
	("j" hydra-compilation-error-next)
	("<down>" hydra-compilation-error-next)
	("k" hydra-compilation-error-previous)
	("<up>" hydra-compilation-error-previous)
	("l" hydra-compilation-error-list :exit t)
	("o" hydra-compilation-error-list :exit t)
	("q" hydra-compilation-error-quit nil :color blue))

(defun hydra-compilation-error-next ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))

(defun hydra-compilation-error-previous ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-previous-error 1)))

(defun hydra-compilation-error-list ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-error-overview)))

(defun hydra-compilation-error-quit ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(delete-other-windows)))

(defun hydra-compilation-error-body-pre ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))
#+END_SRC

** hydra-multiple-cursors

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/multiple-cursors
(defhydra hydra-multiple-cursors (:hint nil :idle 0.2)
	"
    			 ^Up^                   ^Down^            ^Other^
   ╭───^^─────────────────────────^^────────────^^───────────────────╯
    [_S-<up>_] Next      [_S-<down>_] Next       [_l_] Edit lines
      [_<up>_] Skip        [_<down>_] Skip       [_a_] Mark all
    [_M-<up>_] Unmark    [_M-<down>_] Unmark     [_r_] Mark by regexp
    ^ ^                     [_q_] Quit hydra     [_Q_] Quit mc-mode
	"
	("l" mc/edit-lines :exit t)
	("a" mc/mark-all-like-this :exit t)
	("n" mc/mark-next-like-this)
	("N" mc/skip-to-next-like-this)
	("M-n" mc/unmark-next-like-this)
	("S-<down>" mc/mark-next-like-this)
	("<down>" mc/skip-to-next-like-this)
	("M-<down>" mc/unmark-next-like-this)
	("p" mc/mark-previous-like-this)
	("P" mc/skip-to-previous-like-this)
	("M-p" mc/unmark-previous-like-this)
	("S-<up>" mc/mark-previous-like-this)
	("<up>" mc/skip-to-previous-like-this)
	("M-<up>" mc/unmark-previous-like-this)
	("S-<down-mouse-1>" mc/add-cursor-on-click)
	("r" mc/mark-all-in-region-regexp :exit t)
  ("Q" (multiple-cursors-mode -1) :exit t)
	("q" nil))
(global-set-key (kbd "C-<") 'hydra-multiple-cursors/body)
(global-set-key (kbd "M-+") 'hydra-multiple-cursors/body)
  #+END_SRC

** hydra-highlight-changes

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-changes
			(:body-pre (highlight-changes-visible-mode +1)
      :hint nil
      :idle 0.5)
			"
    Highlight changes
  ╭───────────────────╯
	  _<up>_: next change       _q_uit
  _<down>_: previous change   _Q_uit and turn off highlighting 
	"
			("<down>" highlight-changes-next-change)
			("<up>" highlight-changes-previous-change)
			("<right>" highlight-changes-next-change)
			("<left>" highlight-changes-previous-change)
			("j" highlight-changes-next-change)
			("k" highlight-changes-previous-change)
			("n" highlight-changes-next-change)
			("p" highlight-changes-previous-change)
			("Q" (highlight-changes-visible-mode -1) :color blue)
			("q" nil :color blue))
#+END_SRC

** hydra-highlight-symbol

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-symbol
			(:pre (highlight-symbol-at-point) 
      :hint nil
			 :idle 0.5)
			"
   Highlight symbol
 ╭──────────────────╯
    _<up>_: previous occurrence    _r_: replace occurrences     _q_uit 
  _<down>_: next occurrence        
	"
			("<down>" highlight-symbol-next)
			("<up>" highlight-symbol-prev)
			("<right>" highlight-symbol-next)
			("<left>" highlight-symbol-prev)
			("j" highlight-symbol-next)
			("k" highlight-symbol-prev)
			("n" highlight-symbol-next)
			("p" highlight-symbol-prev)
			("c" highlight-symbol-count)
			("r" highlight-symbol-query-replace)
			("l" highlight-symbol-list-all)
			("q" highlight-symbol-remove-all :color blue))
#+END_SRC

** hydra-transpose

Taken from https://github.com/abo-abo/hydra/wiki/Emacs

#+BEGIN_SRC emacs-lisp
(defhydra hydra-transpose (:color red)
	"Transpose"
	("c" transpose-chars "characters")
	("w" transpose-words "words")
	("x" transpose-sexp "expressions")
	("l" transpose-lines "lines")
	("s" transpose-sentences "sentences")
	("p" transpose-paragraphs "paragraphs")
	("o" org-transpose-words "Org-words")
	("e" org-transpose-element "Org-elements")
	("t" org-table-transpose-table-at-point "Org-table")
	("C-t" nil nil :color blue)
	("q" nil "cancel" :color blue))
(global-set-key (kbd "C-t") 'hydra-transpose/body)
#+END_SRC

** TODO hydra-macro

Inspired by: https://github.com/abo-abo/hydra/wiki/Macro
#+BEGIN_SRC emacs-lisp
(defhydra hydra-macro (:hint nil :color pink :pre 
                             (when defining-kbd-macro
															 (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_i_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 _j_ ←   → _l_       [_o_] edit       [_a_] add       [_x_] register     
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_k_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("j" kmacro-start-macro :color blue)
  ("l" kmacro-end-or-call-macro-repeat)
  ("i" kmacro-cycle-ring-previous)
  ("k" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))
#+END_SRC

** hydra: end
  #+BEGIN_SRC emacs-lisp
		)                   
#+END_SRC
