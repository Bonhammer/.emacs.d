#+TITLE: Literate Emacs configuration
#+AUTHOR: Timm Lichte
#+FILETAGS: emacs
#+STARTUP: indent
#+STARTUP: hideblocks content
#+TODO: TODO | DONE CANCELED

http://emacs-bootstrap.com/

* General appearence

** Toolbar

Don't show toolbar:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
#+END_SRC

** Signals

No beep:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

** Syntax highlighting

Brackets:
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Apply syntax highlighting to all buffers:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

*** highlight-symbol

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :config
  (setq highlight-symbol-idle-delay 0.2)
  (add-hook 'highlight-symbol-mode-hook
            (function
             (lambda () (highlight-symbol-nav-mode +1)))))
#+END_SRC

** Lines

Highlight line of cursor:
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Soft-wrap lines:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Line numbers:
#+BEGIN_SRC emacs-lisp
;; (global-linum-mode t)
;; (setq linum-format " %3d ")
#+END_SRC

** Cursor

Cursor blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 1)										; blink
(setq blink-cursor-blinks 0)						; blink forever
#+END_SRC

** Theme

Theme:
#+BEGIN_SRC emacs-lisp
(setq themes-dir
      (expand-file-name "themes" user-emacs-directory))
(add-to-list 'custom-theme-load-path themes-dir)
(load-theme 'monokai t)
#+END_SRC

** Mode line and window labels

Mode line:
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
	:ensure t
	:init
	;; (setq sml/theme 'dark)
	(setq sml/no-confirm-load-theme t)
	:config
	(sml/setup)
	)
#+END_SRC

Show file path in window title:
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '(buffer-file-name "%b - %f" ; File buffer
        (dired-directory dired-directory ; Dired buffer
         (revert-buffer-function "%b" ; Buffer Menu
																 ("%b - Dir: " default-directory))))) ; Plain buffer
#+END_SRC

Show date and time:
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(display-time-mode +1)
#+END_SRC

Fringe style:
#+BEGIN_SRC emacs-lisp
;; (set-face-attribute 'fringe nil :background "#3F3F3F" :foreground "#3F3F3F")
#+END_SRC

** Distraction-free mode

Distraction-free mode:
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
	:ensure t
	:bind
	(:map writeroom-mode-map
				("C-M-<" . writeroom-decrease-width)
				("C-M->" . writeroom-increase-width)
				("C-M-=" . writeroom-adjust-width)
				("C-<f10>" . writeroom-toggle-mode-line)
				)
	)
(global-set-key (kbd "<f10>") 'writeroom-mode)
#+END_SRC

** Font 

Toggle proportional mode when appropriate.
Inspired by https://ogbe.net/blog/toggle-serif.html
#+BEGIN_SRC emacs-lisp
(defvar font-preserve-default-list nil
  "A list holding the faces that preserve the default family and
  height when TOGGLE-SERIF is used.")
(setq font-preserve-default-list
      '(;; LaTeX markup
        font-latex-math-face
        font-latex-sedate-face
        font-latex-warning-face
        ;; org markup
        org-latex-and-related
        org-meta-line
        org-verbatim
        org-block-begin-line
        ;; syntax highlighting using font-lock
        font-lock-builtin-face
        font-lock-comment-delimiter-face
        font-lock-comment-face
        font-lock-constant-face
        font-lock-doc-face
        font-lock-function-name-face
        font-lock-keyword-face
        font-lock-negation-char-face
        font-lock-preprocessor-face
        font-lock-regexp-grouping-backslash
        font-lock-regexp-grouping-construct
        font-lock-string-face
        font-lock-type-face
        font-lock-variable-name-face
        font-lock-warning-face))
(defun toggle-proportional ()
  "Change the default face of the current buffer to use a proportional family."
  (interactive)
  (when (display-graphic-p)  ;; this is only for graphical emacs
    ;; the serif font familiy and height, save the default attributes
    (let ((proportional-fam "Segoe UI")
          (proportional-height 125)
          (default-fam (face-attribute 'default :family))
          (default-height (face-attribute 'default :height)))
      (if (not (bound-and-true-p default-cookie))
          (progn (make-local-variable 'default-cookie)
                 (make-local-variable 'preserve-default-cookies-list)
                 (setq preserve-default-cookies-list nil)
                 ;; remap default face to serif
                 (setq default-cookie
                       (face-remap-add-relative
                        'default :family proportional-fam :height proportional-height))
                 ;; keep previously defined monospace fonts the same
                 (dolist (face font-preserve-default-list)
                   (add-to-list 'preserve-default-cookies-list
                                (face-remap-add-relative
                                 face :family default-fam :height default-height)))
                 (message "Turned on proportional font."))
        ;; undo changes
        (progn (face-remap-remove-relative default-cookie)
               (dolist (cookie preserve-default-cookies-list)
                 (face-remap-remove-relative cookie))
               (setq default-cookie nil)
               (setq preserve-default-cookies-list nil)
               (message "Restored default fonts."))))))
#+END_SRC

* Minibuffer

Shorten yes/no answers to y/n:
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** ido, ivy, imenu

*** ido

#+BEGIN_SRC emacs-lisp
;; ;; ido improves buffer switching experience
;; (ido-mode 1)
;; (ido-everywhere 1)
;; ;; add vertical mode to ido
;; (use-package ido-vertical-mode	
;; 	:ensure t
;; 	:config (ido-vertical-mode 1)	)
;; ;; add grid mode
;; (use-package ido-grid-mode
;; 	:ensure t
;; 	:config (ido-grid-mode 1))												
;; ;; add flx to ido 
;; (use-package flx-ido
;; 	:ensure t
;; 	:config 
;; 	(flx-ido-mode 1)
;; 	;; disable ido faces to see flx highlights.
;; 	(setq ido-enable-flex-matching t)
;; 	(setq ido-use-faces nil))
#+END_SRC

*** Recent files

#+BEGIN_SRC emacs-lisp
;; ;; recent files
;; (require 'recentf)
;; (recentf-mode 1)
;; ; 50 files ought to be enough.
;; (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
;; (setq recentf-max-saved-items 50)
;; (defun ido-recentf-open ()
;; 	"Use `ido-completing-read' to \\[find-file] a recent file"
;; 	(interactive)
;; 	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
;; 			(message "Opening file...")
;; 		(message "Aborting")))

#+END_SRC

*** ivy, counsel, swiper

#+BEGIN_SRC emacs-lisp
;; ;; counsel adds fuzzy search to command completion 
;; (use-package counsel
;; 	:ensure t
;; 	:config
;; 	(setq ivy-display-style 'fancy)
;; 	(setq ivy-re-builders-alist ; use flx
;; 				'((t . ivy--regex-fuzzy)))
;; 	(setq ivy-initial-inputs-alist nil) ; omit ^
;; 	(setq ivy-wrap t) ;; cycle through results
;; 	:bind
;; 	("M-x" . counsel-M-x)
;; 	("C-ß" . ivy-imenu-anywhere) ; ivy + imenu
;; 	)
;; ;; swiper
;; (use-package swiper
;; 	:ensure t
;; 	:config
;; 	;; use swiper for buffer search
;; 	(add-hook 'prog-mode-hook
;; 						(lambda ()
;; 							(local-set-key (kbd "C-s") 'swiper)))
;; 	;; (global-set-key (kbd "C-s") 'swiper) ; not good in text-mode
;; 	)
#+END_SRC

*** imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
	:ensure t)
(use-package imenu-list
	:ensure t
	:bind
	("C-?" . imenu-list)
	:init
	(setq imenu-list-focus-after-activation t)
	;; (setq imenu-list-auto-resize t)
	(setq imenu-list-position (quote left))
	(setq imenu-list-size 30)
	:config
	(add-hook 'text-mode-hook 'imenu-list-minor-mode)
	(add-hook 'prog-mode-hook 'imenu-list-minor-mode)
	)
(add-hook 'imenu-list-minor-mode-hook (lambda () (toggle-truncate-lines))) ; FIXME
(setq org-imenu-depth 4)
#+END_SRC

*** smex

Smex helps to remember often used commands; used by ido and counsel
#+BEGIN_SRC emacs-lisp
;; (use-package smex
;; 	:ensure t)
#+END_SRC

** helm

#+BEGIN_SRC emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 100)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01		; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t		 ; do not display invisible candidates
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t
					helm-mode-fuzzy-match t 			; global fuzzy match
					helm-buffers-fuzzy-matching t
					helm-recentf-fuzzy-match t
					helm-M-x-fuzzy-match t
					helm-imenu-fuzzy-match t
					helm-completion-in-region-fuzzy-match t
					helm-apropos-fuzzy-match t
					helm-autoresize-mode 1 				; re-size the completion window based on number of candidates
					helm-adaptive-mode t					; show commonly used commands first
					)
		(setq bibtex-completion-bibliography (concat home-directory "/Dropbox/Forschung/timm-bib.bib")
					bibtex-completion-library-path (concat home-directory "/ownCloud/Bib") ; directory of PDFs
					;; bibtex-completion-notes-path "~/Dropbox/bibliography/helm-bibtex-notes"
					)
    (helm-mode)

		;; http://emacs.stackexchange.com/a/7896/12336
		;; <return> opens directory in helm-find-files, not dired
		(defun fu/helm-find-files-navigate-forward (orig-fun &rest args)
			(if (file-directory-p (helm-get-selection))
					(apply orig-fun args)
				(helm-maybe-exit-minibuffer)))
		(advice-add 'helm-execute-persistent-action :around #'fu/helm-find-files-navigate-forward)
		(define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
		;; <backspace> before backslash lets helm-find-files  move one directory up
		(defun fu/helm-find-files-navigate-back (orig-fun &rest args)
			(if (= (length helm-pattern) (length (helm-find-files-initial-input)))
					(helm-find-files-up-one-level 1)
				(apply orig-fun args)))
		(advice-add 'helm-ff-delete-char-backward :around #'fu/helm-find-files-navigate-back)
		;; https://redd.it/3f55nm
		;; remove . and .. from helm-find-files
		(advice-add 'helm-ff-filter-candidate-one-by-one
								:around (lambda (fcn file)
													(unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
														(funcall fcn file))))
		)
  :bind (("M-y" . helm-mini)
				 ("C-x C-r" . helm-recentf)
         ("C-h a" . helm-apropos)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
				 ("C-x C-f" . helm-find-files)
         ("C-x C-y" . helm-show-kill-ring)
         ("C-x y" . helm-show-kill-ring)
         ("C-x SPC" . helm-all-mark-rings)
         ("C-x C-SPC" . helm-all-mark-rings)				 
         ("M-x" . helm-M-x)
         ("C-s" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ("C-x c y" . helm-yas-complete)
         ("C-x c Y" . helm-yas-create-snippet-on-region)
         ("C-x c SPC" . helm-all-mark-rings)
				 ("C-ß" . helm-imenu)
				 ("C-S-?" . helm-imenu-anywhere)
				 )
	:config
	(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; complete with <tab> (default is <ret>)
	(define-key helm-map (kbd "C-z") 'helm-select-action) ; show actions (default is <tab>)
)
(ido-mode -1)														; turn off ido mode, just in case

;; helm-flx: improves fuzzy matching
(use-package helm-flx
	:ensure t
	:after helm
	:config
	(helm-flx-mode +1))
;; helm-fuzzier: improves fuzzy matching even more by taking more candidates into account
(use-package helm-fuzzier
	:ensure t
	:after helm
	:config
	(helm-fuzzier-mode +1))

;; list active key bindings 
(use-package helm-descbinds
	:ensure t
  :bind ("C-h b" . helm-descbinds))
#+end_src

*** helm-swoop

#+begin_src emacs-lisp
(use-package helm-swoop
	:ensure t
	:config
	;; Move up and down like isearch
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

	;; From helm-swoop to helm-multi-swoop-all
	(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

	;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
	(define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	
	;; If nil, you can slightly boost invoke speed in exchange for text color
	(setq helm-swoop-speed-or-color t)
	
	;; Optional face for line numbers
	;; Face name is `helm-swoop-line-number-face`
	(setq helm-swoop-use-line-number-face t)

	;; If you prefer fuzzy matching (seems to be already activated)
	;; (setq helm-swoop-use-fuzzy-match t)

	;; Do not call helm-swoop with symbol or word at point
	(setq helm-swoop-pre-input-function
				(lambda () nil))

  :bind ("C-c /" . helm-swoop))
#+END_SRC

*** helm-dash

=helm-dash= depends on =sqlite3= which you probably have to install manually:
http://sqlite.org/download.html

#+BEGIN_SRC emacs-lisp
	(use-package helm-dash
		:ensure t
		:init
		(setq helm-dash-common-docsets			; active in all buffers
					'())
		(setq helm-dash-browser-func 'eww)		; use internal web browser
		(setq helm-dash-docsets-path (expand-file-name (concat home-directory "/ownCloud/.docsets"))) ; FIXME: under windows, helm-dash does not install docsets here but in ~/AppData/... Because of missing tar command?
		(add-hook 'latex-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
		(add-hook 'emacs-lisp-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("EmacsLisp"))))
		(add-hook 'org-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Org_Mode"))))
		(add-hook 'sh-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Bash"))))
		(add-hook 'python-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Python 3" "SciPy" "NumPy"))))
		:bind
		(("C-h d" . helm-dash))
		)
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
(use-package which-key
	:ensure t
	:config
	(which-key-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; M-x in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-x") 'abort-recursive-edit)))

;; M-y in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-y") 'abort-recursive-edit)))

;; C-ß in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-ß") 'abort-recursive-edit)))

;; C-s in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-s") 'abort-recursive-edit)))

;; (global-set-key (kbd "C-x C-b") 'switch-to-buffer) ; instead of 'list-buffers (see helm)
;; (global-set-key (kbd "C-x b") 'ibuffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer)  
#+END_SRC

* Major modes

** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode										; for improved html support
	:ensure t
	:mode
	("\\.phtml\\'" . web-mode)
	("\\.tpl\\.php\\'" . web-mode)
	("\\.[agj]sp\\'" . web-mode)
	("\\.as[cp]x\\'" . web-mode)
	("\\.erb\\'" . web-mode)
	("\\.mustache\\'" . web-mode)
	("\\.djhtml\\'" . web-mode)
	("\\.html?\\'" . web-mode)
	("\\.xml\\'" . web-mode)
	("\\.css\\'" . web-mode)
)
#+END_SRC

** Python


*** elpy

Prerequisites as for Python:
#+BEGIN_SRC bash
	sudo pip install jedi flake8 importmagic autopep8 # Elpy's recommendation
	sudo pip install pylint virtualenv epc # Zamansky's recommendation
#+END_SRC

#+BEGIN_SRC emacs-lisp
	(use-package elpy
		:ensure t
		:defer 2
		:config
		(progn
			;; Use Flycheck instead of Flymake
			(when (require 'flycheck nil t)
				(remove-hook 'elpy-modules 'elpy-module-flymake)
				(remove-hook 'elpy-modules 'elpy-module-yasnippet)
				(remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
				(add-hook 'elpy-mode-hook 'flycheck-mode))
			(elpy-enable)
			(define-key python-mode-map (kbd "C-h f") 'python-eldoc-at-point)
			;; highlight-indentation is ugly
			(add-hook 'elpy-mode-hook '(lambda () (highlight-indentation-mode -1)))
			;; jedi is great
			(setq elpy-rpc-backend "jedi")))
#+END_SRC

*** company-jedi

#+BEGIN_SRC emacs-lisp
;; Use Company for auto-completion interface.
(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi))

(use-package company-jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'my/python-mode-hook))
#+END_SRC


** js2-mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode										; for improved JavaScript support
	:ensure t
	:mode
	("\\.js\\'" . js2-mode))
#+END_SRC

** org-mode

Must appear before LaTeX stuff!

http://pages.sachachua.com/.emacs.d/Sacha.html#orgfe5d909
http://doc.norang.ca/org-mode.html#Setup

#+BEGIN_SRC emacs-lisp
(use-package org
:ensure t
:config
(progn
	;; config stuff
	)
:bind
;; ("C-c C-b" . org-mark-ring-goto)
)
#+END_SRC

*** Files

#+BEGIN_SRC emacs-lisp
	(defvar org-directory)
	(setq org-directory (concat notes-dir "/org"))
	(global-set-key (kbd "<f9> u") 'tl/update-org-agenda-files)

	(defun tl/update-org-agenda-files ()
		(interactive)
		(setq org-agenda-files
					(append
					 (list org-directory)
					 (file-expand-wildcards (concat org-directory "/*/*.org"))))
		(add-links-to-org-agenda-files) ; of the current buffer
		(customize-save-variable 'org-agenda-files org-agenda-files)
		(message "org-agenda-files updated")
		)

	;; (if (eq org-agenda-files nil)						; FIXME
	;; 		()
	;; 	())

	;; ;; Doing this at every start-up is maybe not a good idea:
	;; (setq org-agenda-files
	;; 			(append
	;; 			 (list org-directory)
	;; 			 (file-expand-wildcards (concat org-directory "/*/*.org"))))

	;; set refile targets to move entries inside org-agenda 
	(setq org-refile-targets '(
														 (nil :maxlevel . 2)             ; refile to headings in the current buffer
														 (org-agenda-files :maxlevel . 2) ; refile to any of these files
														 ))
#+END_SRC

*** babel

Preserve indentation in source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

*** General keys

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9> c") 'org-goto-calendar)
  (global-set-key (kbd "<f9> a") 'org-agenda-list)
  (global-set-key (kbd "<f9> t") 'org-todo-list)
  (global-set-key (kbd "C-<f9>") 'org-cycle-agenda-files)
  (global-set-key (kbd "<f9> s") 'org-search-view)
  (global-set-key (kbd "<f9> f") 'org-search-view)
  (global-set-key (kbd "<f9> l") 'org-tags-view)
  (global-set-key (kbd "<f9> r") 'org-reload)
  (global-set-key (kbd "<f9> w")
                  (lambda() (interactive)(find-file (concat org-directory "/forschung/wip.org"))))
  (global-set-key (kbd "<f9> n")
                  (lambda() (interactive)(find-file (concat org-directory "/notes.org"))))
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-<tab>") nil )
    (define-key org-mode-map (kbd "S-<up>") nil )
    (define-key org-mode-map (kbd "S-<down>") nil )
    ;; (define-key org-mode-map (kbd "S-<left>") nil )
    ;; (define-key org-mode-map (kbd "S-<right>") nil )
    (define-key org-mode-map (kbd "C-c C-f") 'org-footnote-action )
    (define-key org-mode-map (kbd "C-c C-x C-b") 'org-tree-to-indirect-buffer ))

  ;; (with-eval-after-load 'org-agenda
  ;;   (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+END_SRC

*** General appearence

**** Lists

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

**** Fonts

#+begin_src emacs-lisp
	(add-hook 'org-mode-hook (lambda ()
														 (variable-pitch-mode t)
														 ;; (text-scale-increase 0.5)
														 ))

	;; (set-face-attribute 'org-block-background nil :inherit 'fixed-pitch)
	(custom-set-variables
	 '(org-ref-label-color "magenta")
	 '(org-ref-ref-color "Deepskyblue1")
	 )
	(custom-set-faces
	 '(org-done ((t (:overline t))))
	 '(org-todo ((t (:overline t))))
	 '(org-block ((t (:inherit fixed-pitch :background "#3E3D31")))) ; org-mode >9
	 '(org-block-background ((t (:inherit fixed-pitch :background "#3E3D31"))))
	 '(org-block-begin-line ((t (:underline t))))
	 '(org-block-end-line  ((t (:overline t))))
	 '(org-level-1 ((t (:inherit outline-1 :overline t :height 1.5))))
	 '(org-level-2 ((t (:inherit outline-2 :overline t :height 1.25))))
	 '(org-level-3 ((t (:inherit outline-3 :height 1.1))))
	 '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
	 '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
	 )

	(with-eval-after-load 'org
		(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-latex-and-related nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-link nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
		)

	(setq org-hide-emphasis-markers t)

#+end_src

**** Bullets, folding symbols, HTML and LaTeX symbols

#+begin_src emacs-lisp
;; nicer bullets
(use-package org-bullets
	:ensure t
	:init
	(setq org-bullets-bullet-list
				'("◉" "◎" "○" "●" "►" "♦" "◇"))
	:config 
	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
	)

;; folding symbol
(setq org-ellipsis " ▼")

;; replace HTML/LaTeX code by UTF-8 characters (see org-pretty-entities for an enumeration)
(setq org-pretty-entities t)

#+END_SRC

*** Modules

See http://orgmode.org/worg/org-contrib/

#+BEGIN_SRC emacs-lisp
;; (setq org-modules '( ;; org-bbdb
;;                       ;; org-gnus
;;                       ;; org-drill
;;                       ;; org-info
;;                       ;; org-jsinfo
;;                       ;; org-habit
;;                       ;; org-irc
;;                       ;; org-mouse
;;                       ;; org-protocol
;;                       ;; org-annotate-file
;;                       ;; org-eval
;;                       ;; org-expiry
;;                       ;; org-interactive-query
;;                       ;; org-man
;;                       ;; org-collector
;;                       ;; org-panel
;;                       ;; org-screen
;;                       ;; org-toc
;; 											))
;; (eval-after-load 'org
;;  '(org-load-modules-maybe t))
;; (setq org-expiry-inactive-timestamps t)
#+END_SRC

*** Miscellaneous settings

Selection
#+BEGIN_SRC emacs-lisp
(setq org-support-shift-select t)
#+END_SRC


Source blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Todo lists
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

Links
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

Block
#+BEGIN_SRC emacs-lisp
(setq org-hide-block-startup t) 				; hide blocks at startup
#+END_SRC

Indent automatically
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

Support for inline tasks
#+BEGIN_SRC emacs-lisp
(load "org-inlinetask")
(define-key org-mode-map (kbd "C-c C-x C-t") 'org-inlinetask-insert-task)
#+END_SRC

*** Newline

#+BEGIN_SRC emacs-lisp
  (defun tl/org-return ()
    (interactive)
    (if (not (org-table-p))
        (org-return)
      (let ((home (point)))
        (org-table-insert-row t)
        (goto-char home))
      (org-table-wrap-region nil))
  )

  (defun tl/org-shift-return ()
    (interactive)
    (let ((home (point)))
      (org-table-insert-row t)
      (goto-char home))
    (org-table-next-row)
  )

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<return>") 'tl/org-return) ; not org-table-next-row
    (define-key org-mode-map (kbd "S-<return>") 'tl/org-shift-return )) ; not org-table-copy-down
#+END_SRC

*** LaTeX support

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((latex . t)))
(setq org-highlight-latex-and-related '(latex script entities)) ; inline sytax highlighting
;; (add-to-list 'org-latex-packages-alist '("" "tikz" t))					; unfortunately this breaks the color of fonts in inline previews
;; (add-to-list 'org-latex-packages-alist '("" "forest" t))
(plist-put org-format-latex-options :scale 1.3) ; scale inline PNGs
#+END_SRC

*** org-ref

#+BEGIN_SRC emacs-lisp
;; (setq org-ref-completion-library 'org-ref-ivy-cite) ; must appear before org-ref
(use-package org-ref
	:ensure t
	:after org
	:init
	(require 'org-ref) 										; don't know why I need this
	(setq reftex-default-bibliography '((concat home-directory "/Dropbox/Forschung/timm-bib.bib"))) ; FIXME
	(setq org-ref-default-bibliography (concat home-directory "/Dropbox/Forschung/timm-bib.bib")
			;; org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
				org-ref-pdf-directory (concat home-directory "/ownCloud/Bib")
				)
	:config
	:bind (:map org-mode-map
							("C-c ]" . org-ref-helm-insert-cite-link)
							("C-c )" . org-ref-helm-insert-ref-link)
							("C-c (" . org-ref-helm-insert-label-link))
)
#+END_SRC

*** Plantuml

http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html

 #+BEGIN_SRC emacs-lisp
(setq org-plantuml-jar-path
      (expand-file-name "plantuml.jar" org-directory))
(org-babel-do-load-languages  'org-babel-load-languages '((plantuml . t)))
#+END_SRC

*** Spell checking
#+BEGIN_SRC emacs-lisp
;; ispell
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
;; flyspell
;; http://emacs.stackexchange.com/a/9347/12336
;; NO spell check for embedded snippets
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let ((rlt ad-return-value)
        (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
        (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
        old-flag
        b e)
    (when ad-return-value
      (save-excursion
        (setq old-flag case-fold-search)
        (setq case-fold-search t)
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t)))
        (setq case-fold-search old-flag))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

*** Agenda

Show notifications of agenda events:
#+BEGIN_SRC emacs-lisp
(use-package org-alert
	:ensure t
	)
#+END_SRC

Add linked org-mode files to =org-agenda-files=:
#+BEGIN_SRC emacs-lisp 
	(defun add-links-to-org-agenda-files ()
		"Inspired by: http://stackoverflow.com/questions/38061773/add-linked-org-files-to-org-agenda-files"
		 (interactive)
		 (princ "Added the following files to org-agenda-files:")
		 (org-element-map  
				 (org-element-parse-buffer)
				 'link
			 (lambda (x)
				 (let ((org-link-path (org-element-property :path x))
							 (org-link-type (org-element-property :type x)))
					 (when (and (equal org-link-type "file") ; only links to files
										(string-prefix-p "~/" org-link-path) ; relative paths are bad
										(equal "org" (file-name-extension org-link-path)) ;only org-mode files
										(file-exists-p org-link-path) ; only existing files
										)
							 (princ (concat " " org-link-path))
							 (add-to-list 'org-agenda-files org-link-path)
					 )))))
#+END_SRC

Integrate Google Calendar with org-gcal:
#+BEGIN_SRC emacs-lisp
	(setq package-check-signature nil)

	(use-package org-gcal
		:ensure t
		:config
		(when (load-file "~/Dropbox/emacs/gcal-credentials.el")
			(setq org-gcal-client-id my-org-gcal-client-id
						org-gcal-client-secret my-org-gcal-client-secret
						org-gcal-file-alist '((my-gmail-address .  "~/Dropbox/Notizen/org/gcal.org")))
	))
#+END_SRC

*** Links

Links to files are opened in the same window, i.e. the window does not get split:
#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((file . find-file)))
#+END_SRC

*** Tags

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist '((:startgroup . nil)
											("@work" . ?w)
											(:grouptags . nil)
											("admin" . ?a)
											("teaching" . ?t)
											("research" . ?r)
											(:endgroup . nil)

											(:startgroup . nil)
											("research" . ?r)
											(:grouptags . nil)
											("mwe" . nil)									
											("parsing" . nil)
											("linguistics" . nil)
											("formalisms" . nil)
											("philosophy" . nil)
											("logic" . nil)
											("maths" . nil)
											("computerScience" . nil)
											("xmg" . nil)											
											(:endgroup . nil)

											(:startgroup . nil)
											("science" . ?h)
											(:grouptags . nil)
											("linguistics" . nil)
											("computationalLinguistics" . nil)
											("philosophy" . nil)
											("logic" . nil)
											("maths" . nil)
											("computerScience" . nil)
											(:endgroup . nil)

											(:startgroup . nil)
											("linguistics" . ?h)
											(:grouptags . nil)
											("syntax" . nil)
											("semantics" . nil)
											("pragmatics" . nil)
											("phonology" . nil)
											("morphology" . nil)
											("corpora" . nil)
											(:endgroup . nil)

											(:startgroup . nil)
											("computationalLinguistics" . ?h)
											(:grouptags . nil)
											("parsing" . nil)
											("generation" . nil)
											("formalisms" . nil)
											("corpora" . nil)
											("speechRecognition" . nil)
											("machineLearning" . nil)
											(:endgroup . nil)

											
											(:startgroup . nil)
											("@home" . ?h)
											(:grouptags . nil)
											("spenden" . nil)
											(:endgroup . nil)

											(:startgroup . nil)
											("software" . ?h)
											(:grouptags . nil)
											("programming" . nil)
											("nlp" . nil)
											("os" . nil)
											("xmg" . nil)											
											(:endgroup . nil)

											(:startgroup . nil)
											("programming" . ?p)
											(:grouptags . nil)
											("emacs" . ?m)
											("latex" . ?x)
											("langsci" . ?l)
											("python" . ?y)
											("javascript" . ?j)
											("perl" . nil)
											("php" . nil)
											("shellscript" . nil)											
											(:endgroup . nil)
											))
#+END_SRC

*** Tables

http://emacs.stackexchange.com/a/28298/12336
#+BEGIN_SRC emacs-lisp
(defun org-table-goto-col-beginning ()
  "Go to beginning of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (org-table-begin))
    (org-table-goto-column col))
  (point))

(defun org-table-col-beginning ()
  "Return beginning position of current column."
  (save-excursion
    (org-table-goto-col-beginning)))

(defun org-table-goto-col-end ()
  "Goto end of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (1- (org-table-end)))
    (org-table-goto-column col)
    (skip-chars-forward "^|"))
  (point))

(defun org-table-col-end ()
  "Return end position of current column."
  (save-excursion
    (org-table-goto-col-end)))

(defun org-table-select-col ()
  "Select current column."
  (interactive)
  (set-mark (org-table-col-beginning))
  (org-table-goto-col-end))

(defun org-table-copy-col ()
  "Copy current column."
  (interactive)
  (save-excursion
    (org-table-copy-region (org-table-goto-col-beginning)
													 (org-table-goto-col-end))))
#+END_SRC

*** Capture templates

#+BEGIN_SRC emacs-lisp
	(setq org-capture-templates
				'(("a" "Appointment" entry (file (concat org-directory "/gcal.org"))
					 "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
					("t" "Todo" entry (file (concat org-directory "/todo.org"))
					 "* TODO %?\t%^g\n CREATED: %U\n About region:%i\n %a")
					("n" "Note" entry (file+datetree (concat org-directory "/notes.org"))
					 "* %?\t%^g\n CREATED: %U\n About region:%i\n %a")
					("c" "Code" entry (file (concat org-directory "/code.org"))
					 "* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC\n CREATED: %U\n About region:%i\n %a")
					))

	(global-set-key (kbd "<f9> <f9>") 'org-capture)
	;; (global-set-key (kbd "<f9> <f9> t") (lambda () (interactive) (org-capture nil "t")))
#+END_SRC

*** Todo keywords

#+BEGIN_SRC emacs-lisp
;; (setq org-todo-keywords
;;       (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
;;               (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

;; (setq org-todo-keyword-faces
;;       (quote (("TODO" :foreground "red" :weight bold)
;;               ("NEXT" :foreground "blue" :weight bold)
;;               ("DONE" :foreground "forest green" :weight bold)
;;               ("WAITING" :foreground "orange" :weight bold)
;;               ("HOLD" :foreground "magenta" :weight bold)
;;               ("CANCELLED" :foreground "forest green" :weight bold)
;;               ("MEETING" :foreground "forest green" :weight bold)
;;               ("PHONE" :foreground "forest green" :weight bold))))
#+END_SRC

** Calendar

#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)

  (setq calendar-intermonth-text
        '(propertize
          (format "%2d"
                  (car
                   (calendar-iso-from-absolute
                    (calendar-absolute-from-gregorian (list month day year)))))
          'font-lock-face 'font-lock-warning-face))

  (setq calendar-intermonth-header
        (propertize "KW"                  ; or e.g. "KW" in Germany
                    'font-lock-face 'font-lock-keyword-face))

#+END_SRC

*** German holidays

#+BEGIN_SRC emacs-lisp
  (use-package german-holidays
    :ensure t
    :config
    (setq calendar-holidays holiday-german-holidays)
    ;; (setq calendar-holidays holiday-german-BW-holidays)
    )
#+END_SRC

*** calfw 

http://jameswilliams.be/blog/2016/01/11/Taming-Your-GCal.html

 #+BEGIN_SRC emacs-lisp

 	(defvar privat-calendar-settings.el "~/Dropbox/emacs/calendar-calfw-settings.el")

 	(use-package calfw
 		:ensure ;TODO: 
 		:config
 		(require 'calfw-org)
 		(require 'calfw-ical)
 		(setq cfw:render-line-breaker 'cfw:render-line-breaker-simple)

 		(if (file-exists-p privat-calendar-settings.el)
 				(load-file privat-calendar-settings.el)
 			(display-warning "calfw" (concat "Could not load " privat-calendar-settings.el)))

 		(defun my-open-calfw ()
 			(interactive)
 			(cfw:open-calendar-buffer
 			 :contents-sources
 			 (list 
 				(cfw:org-create-source "Orangered1")  ; orgmode source
 				;; (cfw:cal-create-source "Orange") ; diary source
 				(cfw:ical-create-source "timm" gcal-timm.ics "Orangered1") ; google calendar ICS
 				(cfw:ical-create-source "verena" gcal-verena.ics "DarkOliveGreen") ; google calendar ICS
 				(cfw:ical-create-source "emmy" gcal-emmy.ics "CornflowerBlue") ; google calendar ICS
 				(cfw:ical-create-source "clcoll" gcal-clcoll.ics "CornflowerBlue") ; google calendar ICS
 				)))
 		)

 	(global-set-key (kbd "<f7> c") 'my-open-calfw)
 	(define-key cfw:calendar-mode-map (kbd "u") 
 		'(lambda () (interactive)
 			 (when (fboundp 'tl/update-my-calendars) ; tl/update-my-calendars is defined in  privat-calendar-settings.el
 				 (tl/update-my-calendars))
 			 (my-open-calfw)
 			 ))

#+END_SRC

** LaTeX

*** AUCTeX 

#+BEGIN_SRC emacs-lisp
	(use-package tex
		:ensure auctex												; because auctex overwrites tex

		:init

		;; to activate auctex
		(setq TeX-auto-save t)  
		(setq TeX-auto-local
					(expand-file-name "temp" user-emacs-directory))
		(setq TeX-parse-self t)
		(setq-default TeX-master nil)
		(setq TeX-save-query nil) ; autosave before compiling 
		;; (setq TeX-show-compilation t) ; always show and follow TeX output

		;; don't indent
		(setq LaTeX-indent-level 0)
		(setq LaTeX-item-indent 0)

		;; viewer
		(setq TeX-PDF-mode t)
		(setq TeX-source-correlate-mode t)
		(setq TeX-source-correlate-method 'synctex)
		(setq TeX-view-program-list
					'(("Sumatra PDF" ("\"C:/Program Files (x86)/SumatraPDF/SumatraPDF.exe\" -reuse-instance"
														(mode-io-correlate " -forward-search %b %n ") " %o"))))
		(eval-after-load 'tex
			'(progn
				 (assq-delete-all 'output-pdf TeX-view-program-selection)
				 (add-to-list 'TeX-view-program-selection '(output-pdf "Sumatra PDF"))))
		
		;; make LaTeXmk default
		(use-package auctex-latexmk
			:ensure t
			:config
			(auctex-latexmk-setup)
			(setq auctex-latexmk-inherit-TeX-PDF-mode t)
			(setq TeX-command-force "LatexMk")  ;; remember to set path variable accordingly!
			)
		
		:config
	
		;; ;; ivy-bibtex
		;; (use-package ivy-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; (define-key LaTeX-mode-map (kbd "C-l C-r") 'ivy-bibtex)
		;; 	;; The standard function with modified default action  
		;; 	(defun ivy-bibtex (&optional arg)
		;; 		"Search BibTeX entries using ivy. With a prefix ARG the cache is invalidated and the bibliography reread."
		;; 		(interactive "P")
		;; 		(when arg
		;; 			(setq bibtex-completion-bibliography-hash ""))
		;; 		(bibtex-completion-init)
		;; 		(ivy-read "BibTeX Items: "
		;; 							(bibtex-completion-candidates 'ivy-bibtex-candidates-formatter)
		;; 							:caller 'ivy-bibtex
		;; 							:action 'bibtex-completion-insert-key))
		;; 	;; look for local bibliographies
		;; 	;; (require 'ebib)
		;; 	(defun ivy-bibtex-with-local-bibliography ()
		;;     (interactive)
		;;     (let ((bibtex-completion-bibliography
		;; 					 (if (eq major-mode 'latex-mode)
		;; 							 ;; (ebib--get-local-databases)
		;; 							 (bibtex-completion--get-local-databases)
		;; 						 bibtex-completion-bibliography)))
		;; 			(ivy-bibtex)))
		;; 	;; proposal by jagrg: https://github.com/tmalsburg/helm-bibtex/issues/112 
		;; 	(defun bibtex-completion--get-local-databases ()
		;; 		"Return a list of .bib files associated with the current file."
		;; 		(let ((texfile nil)
		;; 					(cb (current-buffer)))
		;; 			(when (and (boundp 'TeX-master)
		;; 								 (stringp TeX-master))
		;; 				(setq texfile (if (file-name-extension TeX-master)
		;; 													TeX-master
		;; 												(concat TeX-master ".tex"))))
		;; 			(with-temp-buffer
		;; 				(if (and texfile (file-readable-p texfile))
		;; 						(insert-file-contents texfile)
		;; 					(insert-buffer-substring cb))
		;; 				(save-match-data
		;; 					(goto-char (point-min))
		;; 					(cond
		;; 					 ;; bibtex
		;; 					 ((re-search-forward "\\\\\\(?:no\\)*bibliography{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(split-string (match-string-no-properties 1) ",[ ]*")))
		;; 					 ;; biblatex
		;; 					 ((re-search-forward "\\\\addbibresource\\(\\[.*?\\]\\)?{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(let ((option (match-string 1))
		;; 													(file (match-string-no-properties 2)))
		;; 											(unless (and option (string-match-p "location=remote" option))
		;; 												(split-string file ",[ ]*")))))
		;; 					 (t
		;; 						bibtex-completion-bibliography))))))
		;; 	:bind (:map LaTeX-mode-map 
		;; 							("C-l C-r" . ivy-bibtex-with-local-bibliography))
		;; 	)

		;; see  pull request: https://github.com/tmalsburg/helm-bibtex/pull/113
		;; ;; helm-bibtex FIXME: 
		;; (use-package helm-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; The standard function with modified default action  
		;; 	;; :bind (:map LaTeX-mode-map ("C-l C-r" . helm-bibtex-with-local-bibliography))
		;; 	)

		;; font keys
		(defun TeX-italic()
			(interactive)
			(TeX-font nil ?\C-i))
		(defun TeX-bold()
			(interactive)
			(TeX-font nil ?\C-b))
		(defun TeX-typewriter()
			(interactive)
			(TeX-font nil ?\C-t))
		(defun TeX-emphasis()
			(interactive)
			(TeX-font nil ?\C-e))
		(defun TeX-smallcaps()
			(interactive)
			(TeX-font nil ?\C-c))
		(defun TeX-italic-replace()
			(interactive)
			(TeX-font t ?\C-i))
		(defun TeX-bold-replace()
			(interactive)
			(TeX-font t ?\C-b))
		(defun TeX-typewriter-replace()
			(interactive)
			(TeX-font t ?\C-t))
		(defun TeX-emphasis-replace()
			(interactive)
			(TeX-font t ?\C-e))
		(defun TeX-smallcaps-replace()
			(interactive)
			(TeX-font t ?\C-c))
		(defun TeX-deletefont()
			(interactive)
			(TeX-font nil ?\C-d))
		(define-key LaTeX-mode-map (kbd "C-c C-f i") 'TeX-italic)
		(define-key LaTeX-mode-map (kbd "C-c C-f b") 'TeX-bold)
		(define-key LaTeX-mode-map (kbd "C-c C-f t") 'TeX-typewriter)
		(define-key LaTeX-mode-map (kbd "C-c C-f e") 'TeX-emphasis)
		(define-key LaTeX-mode-map (kbd "C-c C-f s") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c C-f c") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c C-f d") 'TeX-deletefont)	
		(define-key LaTeX-mode-map (kbd "C-c C-f DEL") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c f i") 'TeX-italic)
		(define-key LaTeX-mode-map (kbd "C-c f b") 'TeX-bold)
		(define-key LaTeX-mode-map (kbd "C-c f t") 'TeX-typewriter)
		(define-key LaTeX-mode-map (kbd "C-c f e") 'TeX-emphasis)
		(define-key LaTeX-mode-map (kbd "C-c f s") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c f c") 'TeX-smallcaps)
		(define-key LaTeX-mode-map (kbd "C-c f d") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c f DEL") 'TeX-deletefont)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! i") 'TeX-italic-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! b") 'TeX-bold-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! t") 'TeX-typewriter-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! e") 'TeX-emphasis-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! s") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c C-f ! c") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! i") 'TeX-italic-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! b") 'TeX-bold-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! t") 'TeX-typewriter-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! e") 'TeX-emphasis-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! s") 'TeX-smallcaps-replace)
		(define-key LaTeX-mode-map (kbd "C-c f ! c") 'TeX-smallcaps-replace)
	
		:bind (:map  LaTeX-mode-map
								 ;; ("C-l C-q" . align-current) ; useful command to align arrays
								 ;; ("C-l H-i" . align-current) ; useful command to align arrays							 
								 ;; keys for error browsing (disabled; see hydra settings)
								 ;; ("<f4>" . TeX-next-error)	 
								 ;; ("S-<f4>" . TeX-previous-error)
								 ;; ("C-<f4>" . TeX-error-overview)
								 ;; miscellaneous keys
								 ("C-c <backspace>" . TeX-clean)
								 ("C-<return>" . LaTeX-close-environment)
								 ;; goto keys
								 ("C-c {" . LaTeX-find-matching-begin)
								 ("C-c }" . LaTeX-find-matching-end)
								 )
		)

	;; unset key for preview 
	(add-hook 'LaTeX-mode-hook
						'(define-key LaTeX-mode-map (kbd "C-c C-p") nil))

#+END_SRC

*** reftex
#+BEGIN_SRC emacs-lisp
(use-package reftex
	:diminish reftex-mode
	:init
	(add-hook 'latex-mode-hook 'turn-on-reftex)
	(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
	(setq reftex-plug-into-AUCTeX t
				;; reftex-ref-style-default-list '("Cleveref" "Hyperref" "Fancyref")
				;; reftex-toc-split-windows-horizontally t
				reftex-ref-macro-prompt nil			; go straight to the labels when referencing
				reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")
				;; reftex-default-bibliography '()
				)

	;; add frametitle to TOC
	(setq reftex-section-levels '(("part" . 0)
																("chapter" . 1)
																("section" . 2)
																("subsection" . 3)
																("subsubsection" . 4)
																("frametitle" . -3)
																("paragraph" . 5)
																("subparagraph" . 6)
																("addchap" . -1)
																("addsec" . -2)))
	
	;; connect reftex to imenu
	(add-hook 'reftex-load-hook 'imenu-add-menubar-index)
	(add-hook 'reftex-mode-hook 'imenu-add-menubar-index)
	
	:config
	
	;; jumping around like in org-mode
	(define-key LaTeX-mode-map (kbd "C-c C-j") 'tl/reftex-in-follow-mode)
	(define-key LaTeX-mode-map (kbd "C-c C-n") 'tl/reftex-next)
	(define-key LaTeX-mode-map (kbd "C-c C-p") 'tl/reftex-previous)
	(defun tl/reftex-in-follow-mode()
		(interactive)
		(setq reftex-toc-follow-mode t)
		(reftex-toc))
	(defun tl/reftex-next ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-next)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	(defun tl/reftex-previous ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-previous)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	
	:bind (:map LaTeX-mode-map
							("C-c ]" . reftex-citation); same as in org-mode
						  ) 
	)
#+END_SRC

*** Beamer

Add \frametitle to outline (and imenu):
#+BEGIN_SRC emacs-lisp
(add-to-list 'TeX-outline-extra '("\\\\frametitle\\b" 4))
#+END_SRC

*** Misc

Make square brackets indent correctly (testing):
#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?\[ "(]" LaTeX-mode-syntax-table)
(modify-syntax-entry ?\] ")[" LaTeX-mode-syntax-table)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
	:ensure t
	:config 
	(defun my-markdown-mode-config ()
		"settings for markdown mode"
		(interactive)
		(setq-default tab-width 4)
		(setq-default indent-tabs-mode t)
		(setq markdown-enable-math t))
	(add-hook 'markdown-mode 'my-markdown-mode-config)
	(setq markdown-enable-math t)
	)
#+END_SRC

** Deft

#+BEGIN_SRC emacs-lisp
(use-package deft												; for displaying list of note files
	:ensure t
  :bind
	("<f9> f" . deft)
	("<f9> o" . deft)
	("<f9> d" . deft)
  :commands (deft)
  :config (setq deft-directory notes-dir
                deft-extensions '("md" "org")
								deft-recursive t
								deft-use-filename-as-title t
								deft-use-filter-string-for-filename t))
#+END_SRC

* Buffer

** General configuration

Automatically update buffers when files change:
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+end_src

Visible bell:
#+begin_src emacs-lisp
(setq visible-bell t)
(setq ring-bell-function (lambda ()
                           (invert-face 'mode-line)
                           (run-with-timer 0.05 nil 'invert-face 'mode-line)))
#+end_src

Delete marked text on typing:
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Use tabs for indent:
#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode t)
#+end_src

Scrolling:
#+begin_src emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000)
;; autoscroll compilation output
(setq compilation-scroll-output t)
;; scroll to the first/last line
(setq scroll-error-top-bottom t)
#+end_src

Show vertical line per indentation level: 
#+begin_src emacs-lisp
(use-package highlight-indent-guides
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
	(setq highlight-indent-guides-method 'character)
	)
#+end_src

** Autocomplete

*** yasnippet (before auto-complete)

#+begin_src emacs-lisp
(use-package yasnippet
	:ensure t
	:config (yas-global-mode 1))
#+end_src

*** auto-complete
Sequence is important!

#+begin_src emacs-lisp
;; (require 'auto-complete)
;; (require 'auto-complete-auctex)
;; (require 'auto-complete-config)
;; (ac-config-default)
;; (setq ac-auto-show-menu t)
;; (setq ac-auto-show-menu 1)
;; (global-auto-complete-mode 1)
;; ;; (add-to-list 'ac-modes 'latex-mode)     ; activate auto-complete for latex <modes (AUCTeX or Emacs' builtin one).
;; (add-hook 'latex-mode-hook (function (lambda ()
;; 																					(ac-source-yasnippet))))
#+end_src

*** company
#+begin_src emacs-lisp
(use-package company
	:ensure t
	:config
	(use-package company-auctex
		:ensure t
		:config (company-auctex-init))
	(add-hook 'after-init-hook 'global-company-mode)
	;; yasnippet integration
	(defvar company-mode/enable-yas t
		"Enable yasnippet for all backends.")
	(defun company-mode/backend-with-yas (backend)
		(if (or (not company-mode/enable-yas)
						(and (listp backend) (member 'company-yasnippet backend)))
				backend
			(append (if (consp backend) backend (list backend))
							'(:with company-yasnippet))))
	(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
	;; some general variables
	(setq company-idle-delay 0.3
				company-minimum-prefix-length 1
				company-selection-wrap-around t
				;; company-show-numbers t
				company-dabbrev-downcase nil
				company-auto-complete nil
				company-transformers '(company-sort-by-occurrence))
	(add-hook 'eshell-mode-hook '(lambda () (setq company-idle-delay 0)))
	(eval-after-load 'company
	  '(progn
	     (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
			 (define-key company-active-map (kbd "<return>") nil)
			 (define-key company-active-map (kbd "RET") nil)
	     ;; (define-key company-active-map (kbd "<tab>") 'company-complete-common)  ; Insert the common part of all candidates.  
	     ;; (define-key company-active-map (kbd "<tab>") 'company-select-next))
		))
	(use-package company-flx
		:ensure t
		:config
		(company-flx-mode +1))
	;; add company to org-mode
 	(add-to-list 'company-backends 'company-capf)
	(defun add-pcomplete-to-capf ()
		(add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
	(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
	)
#+end_src

** Syntax checking

*** flycheck

#+begin_src emacs-lisp
(use-package flycheck
	:ensure t
	:config
	(global-flycheck-mode t)
	(add-hook 'text-mode-hook '(lambda ()(flycheck-mode 0)))
	)
#+end_src

** Spell checking

*** flyspell

#+begin_src emacs-lisp
(setq ispell-program-name "C:\\Program Files (x86)\\Aspell\\bin\\aspell.exe")
(global-set-key (kbd "C-<f6>") 'flyspell-toggle)
(global-set-key (kbd "<f6>") 'flyspell-toggle)
(eval-after-load "flyspell"
	'(dolist
			 (define-key flyspell-mode-map (kbd "M-<f6>") 'ispell-word)
		 (define-key flyspell-mode-map (kbd "<f6>") 'flyspell-next-and-ispell-word)
		 (define-key flyspell-mode-map (kbd "S-<f6>") 'flyspell-previous-and-ispell-word)))

;; remove keybindings for autocorrect 
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-;") nil))
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-.") nil))

;; ;; activate for text
;; (dolist (hook '(text-mode-hook LaTeX-mode-hook))
;; 	(add-hook hook (lambda () (flyspell-mode 1))))

(defun flyspell-toggle (arg)
	(interactive "p")
	(if (bound-and-true-p flyspell-mode)
			(progn
				 (flyspell-mode -1)
			)	 
		(progn
			(flyspell-buffer)
			(flyspell-mode)
			)))

;; move point to previous error
;; http://emacs.stackexchange.com/a/14912/2017
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))))))


(defun flyspell-next-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-next-error)
		(ispell-word)
		)
  )

(defun flyspell-previous-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-previous-error)
		(ispell-word)
		)
  )

#+end_src

** Paren handling

*** smartparens

#+begin_src emacs-lisp
	(use-package smartparens
		:ensure t
		:config
		(use-package smartparens-config)
		(setq sp-autoescape-string-quote nil)
		(--each '(css-mode-hook
							js-mode-hook
							java-mode-hook
							python-mode-hook
							emacs-lisp-mode-hook
							LaTeX-mode-hook
							bibtex-mode-hook
							shell-mode-hook
							sh-mode-hook
							TeX-mode-hook
							markdown-mode-hook
							org-mode-hook)
			(add-hook it #'smartparens-mode))
		(require 'smartparens-latex)
		;; org-mode
		(sp-with-modes 'org-mode
			(sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-before-word-p sp-point-at-bol-p sp-in-math-p) )
			(sp-local-pair "_" "_" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "/" "/" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "~" "~" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "=" "=" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "+" "+" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p tl/sp-point-after-hash-p) )
			(sp-local-pair "$" "$" :unless '(sp-point-after-word-p sp-point-before-word-p) )
			(sp-local-pair "«" "»"))
		)
	(defun tl/sp-point-after-hash-p (id action context)
		"Return t if point is after a hash, nil otherwise.
	This predicate is only tested on \"insert\" action.
	Its definition follows the one of sp-point-after-word-p."
		(when (eq action 'insert)
			(sp--looking-back-p (concat "\\(#\\)" (regexp-quote id)))))

	;; jump to matching paren
	(defun goto-match-paren (arg)
		"Go to the matching  if on (){}[], similar to vi style of % "
		(interactive "p")
		;; first, check for "outside of bracket" positions expected by forward-sexp, etc.
		(cond ((looking-at "[\[\(\{]") (forward-sexp))
					((looking-back "[\]\)\}]" 1) (backward-sexp))
					;; now, try to succeed from inside of a bracket
					((looking-at "[\]\)\}]") (forward-char) (backward-sexp))
					((looking-back "[\[\(\{]" 1) (backward-char) (forward-sexp))
					(t nil)))
	(global-set-key (kbd "C-M-m") 'goto-match-paren)
	(global-set-key (kbd "M-(") 'sp-backward-sexp)
	(global-set-key (kbd "M-)") 'sp-forward-sexp)
	(global-set-key (kbd "M-m") 'goto-match-paren)
	(global-set-key (kbd "M-[") 'sp-beginning-of-sexp)
	(global-set-key (kbd "M-]") 'sp-end-of-sexp)
	(global-set-key (kbd "M-DEL") nil)
	(global-set-key (kbd "M-DEL M-[") 'sp-unwrap-sexp)
#+end_src

*** emacs-pairs

#+begin_src emacs-lisp
;; https://ebzzry.github.io/emacs-pairs.html
;; (defmacro def-pairs (pairs)
;;   `(progn
;;      ,@(loop for (key . val) in pairs
;;           collect
;;             `(defun ,(read (concat
;;                             "wrap-with-"
;;                             (prin1-to-string key)
;;                             "s"))
;;                  (&optional arg)
;;                (interactive "p")
;;                (sp-wrap-with-pair ,val)))))
;; (def-pairs ((paren        . "(")
;;             (bracket      . "[")
;;             (brace        . "{")
;;             (single-quote . "'")
;;             (double-quote . "\"")
;;             (back-quote   . "`")))
;; (global-set-key (kbd "C-[") 'wrap-with-brackets) ; TODO: find nice key bindings
;; (global-set-key (kbd "C-(") 'wrap-with-parens)
;; (global-set-key (kbd "C-{") 'wrap-with-braces)
#+end_src

** Indentation

Auto-indent when yanking
https://www.emacswiki.org/emacs/AutoIndentation

#+begin_src emacs-lisp
(dolist (command '(yank yank-pop))
	(eval `(defadvice ,command (after indent-region activate)
					 (and (not current-prefix-arg)
								(member major-mode '(emacs-lisp-mode lisp-mode
																										 clojure-mode    scheme-mode
																										 haskell-mode    ruby-mode
																										 rspec-mode      python-mode
																										 c-mode          c++-mode
																										 objc-mode       latex-mode
																										 plain-tex-mode))
								(let ((mark-even-if-inactive transient-mark-mode))
									(indent-region (region-beginning) (region-end) nil))))))
#+end_src

** Selection

*** expand-region

#+begin_src emacs-lisp
(use-package expand-region
	:ensure t
	:bind ("C-+" . er/expand-region)
	)
#+end_src

*** Mouse selection

Copy mouse selection to kill-ring:
#+begin_src emacs-lisp
;; (setq mouse-drag-copy-region t)
#+end_src

** Cursor actions

*** ace-jump

#+begin_src emacs-lisp
(use-package ace-jump-mode
	:ensure t
	:bind 
	("C-c SPC" . ace-jump-mode))
#+end_src

*** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
	:ensure t
	:bind
	("C-S-c C-S-c" . mc/edit-lines)
	("C->" . mc/mark-next-like-this)
	("C-<" . mc/mark-previous-like-this)
	("C-c C-<" . mc/mark-all-like-this)
	)
#+end_src

*** point-undo

Cursor position history (LOCAL)

#+begin_src emacs-lisp
(require 'point-undo)
(global-set-key [M-left] 'point-undo)
(global-set-key [M-right] 'point-redo)
(global-set-key (kbd "M-j") 'point-undo)
(global-set-key (kbd "M-k") 'point-redo)
;; focus on line-based jumps
;; http://emacs.stackexchange.com/a/28078/12336
(defvar point-undo-ring-length 100)
(defvar point-undo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-undo-ring)
(defvar point-redo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-redo-ring)
(defun point-undo-pre-command-hook ()
  "Save positions before command."
  (unless (or (eq this-command 'point-undo)
              (eq this-command 'point-redo))
    (let ((line (line-number-at-pos)))
      (when (eq line (cdr (nth 0 (ring-elements point-undo-ring))))
        (ring-remove point-undo-ring 0))
      (ring-insert point-undo-ring (cons (point) line))
      (setq point-redo-ring (make-ring point-undo-ring-length)))))
(add-hook 'pre-command-hook 'point-undo-pre-command-hook)
(defun point-undo-doit (ring1 ring2)
  "ring1, ring2 = {point-undo-ring, point-redo-ring}"
  (condition-case nil
      (progn
        (goto-char (car (nth 0 (ring-elements ring1)))) 
        (ring-insert ring2 (ring-remove ring1 0)))
    (error nil)))
(defun point-undo ()
  "Undo position."
  (interactive)
  (point-undo-doit point-undo-ring point-redo-ring))
(defun point-redo ()
  "Redo position."
  (interactive)
  (when (or (eq last-command 'point-undo)
            (eq last-command 'point-redo))
    (point-undo-doit point-redo-ring point-undo-ring)))
#+end_src

*** goto-last-change

Cursor position undo history:

#+begin_src emacs-lisp
(use-package goto-last-change
	:ensure t
	:bind
	("M-_" . goto-last-change))
#+end_src

** Undo & remove

*** undo-tree

Visualize the undo history.

#+begin_src emacs-lisp
(use-package undo-tree
	:ensure t
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+end_src

*** Remove newlines

http://stackoverflow.com/a/5194503
#+begin_src emacs-lisp
(defun remove-newlines-in-region ()
  "Removes all newlines in the region."
  (interactive)
  (save-restriction
    (narrow-to-region (point) (mark))
    (goto-char (point-min))
    (while (search-forward "\n" nil t) (replace-match " " nil t))))

(defun remove-newline ()
	(save-excursion 
		(search-forward "\n")
		(replace-match " ")))

(defun remove-newlines-or-blank-lines-dwim ()
	(interactive)
	(progn (if (use-region-p)
						 (remove-newlines-in-region)
					 (if (next-line-empty-p)
							 (delete-blank-lines)
						 (remove-newline)
					 ))))

(defun next-line-empty-p ()
  (save-excursion
		(next-line)
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))
#+end_src

*** Remove extra spaces

Remove extra spaces from line or region (TODO):
#+begin_src emacs-lisp
(defun tl/remove-extra-spaces-dwim ()
	"Remove extra spaces in line or in region."
	(interactive)
	(if (region-active-p)
			(save-restriction
				(narrow-to-region (point) (mark))
				(save-excursion 
					(goto-char (point-min))
					(while (re-search-forward "[ ]+" nil t) (replace-match " " nil t))))
		(save-excursion
			(move-beginning-of-line nil)  					; FIXME: undo doesn't see save-excursion
			(while (re-search-forward "[ ]+" (line-end-position) t)
				(replace-match " "))))
	)
#+end_src

*** Tracking changes

http://emacs-fu.blogspot.de/2009/05/tracking-changes.html
#+begin_src emacs-lisp
	;; higlight changes in documents
	(global-highlight-changes-mode t)
	(setq highlight-changes-visibility-initial-state nil); initially hide
	;; toggle visibility
	;; (global-set-key (kbd "<f8>") 'highlight-changes-visible-mode) ;; changes
	;; remove the change-highlight in region
	;; (global-set-key (kbd "S-<f8>") 'highlight-changes-remove-highlight)
	;; if you're not already using it for something else...
	(global-set-key (kbd "<M-prior>") 'highlight-changes-next-change)
	(global-set-key (kbd "<M-next>")  'highlight-changes-previous-change)
	;; faces
	(set-face-foreground 'highlight-changes nil)
	(set-face-background 'highlight-changes "#916868")
	(set-face-foreground 'highlight-changes-delete nil)
	(set-face-background 'highlight-changes-delete "#916868")

	;; http://stackoverflow.com/a/21084181/6452961
	;; show mark in fringe
	(eval-after-load "hilit-chg"
		'(progn
			 (defvar highlight-fringe-mark 'filled-square
				 "The fringe bitmap name marked at changed line.
	Should be selected from `fringe-bitmaps'.")

			 (defadvice hilit-chg-make-ov (after hilit-chg-add-fringe activate)
				 (mapc (lambda (ov)
								 (if (overlay-get ov 'hilit-chg)
										 (let ((fringe-anchor (make-string 1 ?x)))
											 (put-text-property 0 1 'display
																					(list 'left-fringe highlight-fringe-mark)
																					fringe-anchor)
											 (overlay-put ov 'before-string fringe-anchor))
									 ))
							 (overlays-at (ad-get-arg 1))))))
	;; remove highlights on save time
	(add-hook 'after-save-hook
						(lambda ()
							(when highlight-changes-mode
								(save-restriction
									(widen)
									(highlight-changes-remove-highlight (point-min) (point-max))))))
#+end_src

** Switch between buffers

Switching between buffers with C-tab:
#+begin_src emacs-lisp
  (use-package iflipb
    :ensure t
    :config
    (setq iflipb-wrap-around t)
    (setq iflipb-ignore-buffers "^ ")     ; include all buffers
    :bind
    ("<C-tab>" . iflipb-next-buffer))
#+end_src

** Narrowing

http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
"Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
(interactive "P")
(declare (interactive-only))
(cond ((and (buffer-narrowed-p) (not p)) (widen))
			((region-active-p)
			 (narrow-to-region (region-beginning)
												 (region-end)))
			((derived-mode-p 'org-mode)
			 ;; `org-edit-src-code' is not a real narrowing
			 ;; command. Remove this first conditional if
			 ;; you don't want it.
			 (cond ((ignore-errors (org-edit-src-code) t)
							(delete-other-windows))
						 ((ignore-errors (org-narrow-to-block) t))
						 (t (org-narrow-to-subtree))))
			((derived-mode-p 'latex-mode)
			 (LaTeX-narrow-to-environment))
			(t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only
;; copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (define-key LaTeX-mode-map "\C-xn"
              nil)))
#+end_src

** File browser
*** ranger, deer

Use deer instead plain directory listing:
#+begin_src emacs-lisp
(use-package ranger
	:ensure t
	:bind
	("C-x C-d" . deer))

;; open file from inside a buffer
(global-set-key (kbd "C-x f") 'find-file-at-point)
#+end_src

** Commenting

#+begin_src emacs-lisp
(global-set-key (kbd "C-;") 'comment-or-uncomment-region-or-line)
(eval-after-load "LaTeX-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(eval-after-load "markdown-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
				(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)
    (next-line)))
#+end_src

*** Critical markup

#+begin_src emacs-lisp
(use-package cm-mode
	:ensure t
	:config
	(setq-default cm-author "TL"))
#+end_src

** Line actions
*** Delete line
#+begin_src emacs-lisp
;; (global-set-key (kbd "C-d C-o") 'delete-blank-lines) ; not allowed here, see underi-mode.el
;; (global-set-key (kbd "C-d C-m") 'delete-blank-lines)
(global-set-key (kbd "C-S-k") 'kill-whole-line)
;; (global-set-key (kbd "C-k") 'kill-sentence) ; too greedy
(global-set-key (kbd "C-S-d") 'kill-whole-line)
#+end_src

Copy/cut whole line or region:
#+begin_src emacs-lisp
(global-set-key (kbd "C-w") 'xah-cut-line-or-region) ; cut
(global-set-key (kbd "M-w") 'xah-copy-line-or-region) ; copy
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))
(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2016-06-18"
  (interactive)
  (let (-p1 -p2)
    (if current-prefix-arg
        (setq -p1 (point-min) -p2 (point-max))
      (if (use-region-p)
          (setq -p1 (region-beginning) -p2 (region-end))
        (setq -p1 (line-beginning-position) -p2 (line-end-position))))
    (if (eq last-command this-command)
        (progn
          (progn ; hack. exit if there's no more next line
            (end-of-line)
            (forward-char)
            (backward-char))
          ;; (push-mark (point) "NOMSG" "ACTIVATE")
          (kill-append "\n" nil)
          (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
          (message "Line copy appended"))
      (progn
        (kill-ring-save -p1 -p2)
        (if current-prefix-arg
            (message "Buffer text copied")
          (message "Text copied"))))
		;; TL: commented out the following two lines. Cursor remains at region.
    ;; (end-of-line)   
    ;; (forward-char)
    ))
#+end_src

*** New line

#+begin_src emacs-lisp
(global-set-key (kbd "S-<return>") 'smart-open-line)
(global-set-key (kbd "C-x C-<return>") 'smart-open-line)
(global-set-key (kbd "C-S-<return>") 'smart-open-line-above)
(global-set-key (kbd "C-o") 'smart-open-line)
(global-set-key (kbd "C-S-o") 'smart-open-line-above)
;; http://emacsredux.com/blog/2013/03/26/smarter-open-line/
(defun smart-open-line ()
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
;; http://emacsredux.com/blog/2013/06/15/open-line-above/
(defun smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
#+end_src

*** Center line
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-l") 'recenter-top-bottom)
#+end_src

** Capitalization

Toggle letter case:
 #+begin_src emacs-lisp
(global-set-key (kbd "C-9") 'xah-toggle-letter-case) 
(defun xah-toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.

URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
Version 2016-01-08"
  (interactive)
  (let (
        (deactivate-mark nil)
        -p1 -p2)
    (if (use-region-p)
        (setq -p1 (region-beginning)
              -p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alnum:]")
        (setq -p1 (point))
        (skip-chars-forward "[:alnum:]")
        (setq -p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region -p1 -p2)
      (put this-command 'state 1))
     ((equal 1  (get this-command 'state))
      (upcase-region -p1 -p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region -p1 -p2)
      (put this-command 'state 0)))))
#+end_src

** Buffer actions

Open untitled new buffer:
#+begin_src emacs-lisp
(defun xah-new-empty-buffer ()
  "Open a new empty buffer.
URL `http://ergoemacs.org/emacs/emacs_new_empty_buffer.html'
Version 2015-06-12"
  (interactive)
  (let ((buf (generate-new-buffer "untitled")))
    (switch-to-buffer buf)
    (funcall (and initial-major-mode))
    (setq buffer-offer-save t)))
(global-set-key (kbd "<f7> <f7>") 'xah-new-empty-buffer)
#+end_src

Kill buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "M-<f4>") 'kill-this-buffer)
 #+end_src
 
Revert buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'revert-buffer)
 #+END_SRC

* underi-mode

Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 

Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html

#+BEGIN_SRC emacs-lisp
	(define-minor-mode underi-mode
		"Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 
	Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html"
		:lighter " ui"
		;; :global "t"
		:init-value t
		:keymap (let ((map (make-keymap)))

							(define-key input-decode-map (kbd "C-i") (kbd "H-i")) ; to disentangle <tab> and C-i

							;; cursor keys
							(define-key key-translation-map (kbd "M-i") (kbd "<up>"))
							(define-key key-translation-map (kbd "M-k") (kbd "<down>"))
							(define-key key-translation-map (kbd "M-j") (kbd "<left>"))		
							(define-key key-translation-map (kbd "M-l") (kbd "<right>"))
							(define-key key-translation-map (kbd "M-I") (kbd "S-<up>"))
							(define-key key-translation-map (kbd "M-K") (kbd "S-<down>"))
							(define-key key-translation-map (kbd "M-J") (kbd "S-<left>"))		
							(define-key key-translation-map (kbd "M-L") (kbd "S-<right>"))

							;; more cursor keys
							(define-key map (kbd "M-n") 'scroll-up-command)
							(define-key map (kbd "M-p") 'scroll-down-command)
							(define-key map (kbd "M-o") 'point-redo)
							(define-key map (kbd "M-u") 'point-undo)
							(define-key map (kbd "M-z") 'goto-last-change)
							(define-key map (kbd "C-M-i") 'backward-paragraph)
							(define-key map (kbd "C-M-k") 'forward-paragraph)
							(define-key map (kbd "C-M-j") 'left-word)
							(define-key map (kbd "C-M-l") 'right-word)

							(define-key map (kbd "M-s-j")  'windmove-left)
							(define-key map (kbd "M-s-l") 'windmove-right)
							(define-key map (kbd "M-s-i")   'windmove-up)
							(define-key map (kbd "M-s-k")  'windmove-down)

							(define-key key-translation-map (kbd "C-n") (kbd "C-c C-n"))
							(define-key key-translation-map (kbd "C-p") (kbd "C-c C-p"))

							;; delete 
							(define-key map (kbd "C-d") nil)
							(define-key map (kbd "C-d C-k") 'kill-line)
							(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d <left>") 'delete-backward-char)
							(define-key map (kbd "C-d <right>") 'delete-forward-char)
							(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
							(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
							(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-o") 'delete-blank-lines)
							(define-key map (kbd "C-d C-m") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-<return>") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
							(define-key map (kbd "C-d C-e") 'kill-line)
							(define-key map (kbd "C-S-d") 'kill-whole-line)
							(define-key map (kbd "C-d SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d C-SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d )") 'sp-unwrap-sexp)

							;; return
							(define-key input-decode-map (kbd "C-m") (kbd "H-o")) ; to disentangle <return> and C-m
							(define-key key-translation-map (kbd "H-o") (kbd "RET"))
							(define-key map (kbd "C-S-m") 'smart-open-line)

 							;; org-babel
							(define-key org-mode-map (kbd "C-d r") 'org-babel-remove-result)

							;; miscellaneous actions
							(define-key map (kbd "C-j") 'ace-jump-mode)
							(define-key map (kbd "H-i") 'helm-imenu)
							(define-key map (kbd "C-S-i") 'imenu-list)

							map
							)
		(add-hook 'minibuffer-setup-hook 'underi-minibuffer)
		(with-eval-after-load 'org
			(define-key org-mode-map (kbd "C-d c") 'org-table-delete-column )
			(define-key org-mode-map (kbd "C-d C-c") 'org-table-delete-column )
			)																	

	)	
	;; TODO: make C-d switch to delete-mode?
	;; http://stackoverflow.com/a/12010437/6452961

	(defun tl/kill-forward-line (N)
		(interactive)
		(save-excursion
			(when (= (forward-line N) 0)
				(kill-whole-line))))

	(defun underi-minibuffer ()
		"Keymap for the minibuffer."
		(let ((map minibuffer-local-map))

			;; move cursor
			(define-key map (kbd "M-n") 'scroll-up-command)
			(define-key map (kbd "M-p") 'scroll-down-command)
			(define-key map (kbd "M-o") 'point-redo)
			(define-key map (kbd "M-u") 'point-undo)
			(define-key map (kbd "M-z") 'goto-last-change)
			(define-key map (kbd "C-M-i") 'backward-paragraph)
			(define-key map (kbd "C-M-k") 'forward-paragraph)
			(define-key map (kbd "C-M-j") 'left-word)
			(define-key map (kbd "C-M-l") 'right-word)

			;; delete 
			(define-key map (kbd "C-d") nil)
			(define-key map (kbd "C-d C-k") 'kill-line)
			(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d <left>") 'delete-backward-char)
			(define-key map (kbd "C-d <right>") 'delete-forward-char)
			(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
			(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
			(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
			(define-key map (kbd "C-S-d") 'kill-whole-line)
			(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d )") 'sp-unwrap-sexp)
			))

	(define-key helm-map (kbd "H-i") 'helm-select-action) ; show actions (default is <tab>)

	;; (add-hook 'text-mode-hook 'underi-mode) ; superseded by :init-value t
	;; (add-hook 'prog-mode-hook 'underi-mode) ; superseded by :init-value t
#+END_SRC

#+RESULTS:
: helm-select-action

* winkeys-mode

Key bindings roughly following the conventions of the Windows habitat.

#+BEGIN_SRC emacs-lisp
(define-minor-mode winkeys-mode
	"Key bindings roughly following the conventions of the Windows habitat."
	:lighter " wk"
	;; :global "t"
	:init-value t
	:keymap (let ((map (make-keymap)))
						
						;; save
						(define-key map (kbd "C-s") 'save-buffer)
						(define-key map (kbd "C-S-s") 'write-file)

						;; search and replace
						(define-key map (kbd "C-f") 'helm-swoop)
						(define-key map (kbd "C-S-f a") 'helm-multi-swoop-all)
						(define-key map (kbd "C-S-f m") 'helm-multi-swoop-current-mode)
						;; (define-key map (kbd "C-f") 'isearch-search)
						(define-key map (kbd "C-r") 'query-replace)
						(define-key map (kbd "C-S-r") 'query-replace-regexp)
						(define-key map (kbd "C-o") 'helm-find-files)

						;; mark all
						(define-key map (kbd "C-x C-a") 'mark-whole-buffer)
						
						;; quit
						(define-key key-translation-map (kbd "M-q") (kbd "C-g"))

						;; undo/redo
						(define-key map (kbd "C-z") 'undo-tree-undo)
						(define-key map (kbd "C-S-z") 'undo-tree-redo)

						;; press ESC only once
						(define-key map (kbd "<escape>") 'keyboard-escape-quit)
										
						map
						)
	(add-hook 'minibuffer-setup-hook 'winkeys-minibuffer)
	(add-hook 'org-src-mode-hook
						(lambda ()((define-key (kbd "C-s") 'org-edit-src-save))))
	)

(defun winkeys-minibuffer ()
	"Keymap for the minibuffer."
	(let ((map minibuffer-local-map))

		;; undo/redo
		(define-key map (kbd "C-z") 'undo-tree-undo)
		(define-key map (kbd "C-S-z") 'undo-tree-redo)
		
		))

#+END_SRC
 
** TODO How to make this a proper part of the mode, i.e., how to disable this when disabeling the mode?

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm-swoop
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-f") 'tl/helm-swoop-C-s) 
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-f") 'helm-next-line)
	(define-key helm-swoop-map (kbd "C-S-f a") 'helm-multi-swoop-all-from-helm-swoop)
	(define-key helm-swoop-map (kbd "C-S-f m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	(define-key helm-swoop-map (kbd "M-a") 'helm-multi-swoop-all-from-helm-swoop))

;; Let helm-swoop behave more like isearch
(defun tl/helm-swoop-C-s ()
	(interactive)
	(if (boundp 'helm-swoop-pattern)
			(if (equal helm-swoop-pattern "")
					(previous-history-element 1)
				(helm-next-line))
		(helm-next-line)
		))
#+END_SRC

* sr-speedbar

#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
	:ensure t
	:bind
	("C-c C-k C-b" . sr-speedbar-toggle)
	:config
	(setq sr-speedbar-right-side nil)                          ; always on left side
	(add-hook 'speedbar-mode-hook '(lambda () (linum-mode 0))) ; disable linum for speedbar
	(setq speedbar-show-unknown-files t)                       ; show all files
	(setq sr-speedbar-width 30)                                ; default width
	)
#+END_SRC

* Windows, frames

Better keys for switching between windows:
#+BEGIN_SRC emacs-lisp
	;; (when (fboundp 'windmove-default-keybindings)
	;; (windmove-default-keybindings))
	(global-set-key (kbd "M-s-<left>")  'windmove-left)
	(global-set-key (kbd "M-s-<right>") 'windmove-right)
	(global-set-key (kbd "M-s-<up>")   'windmove-up)
	(global-set-key (kbd "M-s-<down>")  'windmove-down)

	;; (global-set-key (kbd "<f2> <left>")  'windmove-left)
	;; (global-set-key (kbd "<f2> <right>") 'windmove-right)
	;; (global-set-key (kbd "<f2> <up>")   'windmove-up)
	;; (global-set-key (kbd "<f2> <down>")  'windmove-down)

	;; clone frame
	;; (global-set-key (kbd "<f2> <f2>") 'make-frame)

	;; split window
	;; (global-set-key (kbd "<f2> v") 'split-window-vertically)
	;; (global-set-key (kbd "<f2> h") 'split-window-horizontally)
	;; (global-set-key (kbd "<f2> b") 'split-window-below)
	;; (global-set-key (kbd "<f2> r") 'split-window-right)

	;; close window
	(global-set-key (kbd "M-<f2>") 'delete-window)

	;; winner mode:
	(winner-mode 1)
	;; (global-set-key (kbd "<f2> z") 'winner-undo) ; undo pane configuration
	;; (global-set-key (kbd "<f2> Z") 'winner-redo) ; redo pane configuration
#+END_SRC

** golden-ratio

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :init
  (golden-ratio-mode 1))
#+END_SRC

* Git

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
	:ensure t
	:bind
	("C-x g" . magit-status)
	;; ("C-x C-g" . magit-status)
	)
#+end_src

** git-gutter

#+begin_src emacs-lisp
(use-package git-gutter
	:ensure t
	:config
	(global-git-gutter-mode +1)
	;; (git-gutter:linum-setup) ; git-gutter is struggling with linum-mode
	(custom-set-variables
	 '(git-gutter:update-interval 2))
	:bind
	("C-x C-g" . nil)
	("C-x C-g TAB" . git-gutter:popup-hunk)
	("C-x C-g _" . git-gutter:revert-hunk)
	("C-x C-g z" . git-gutter:revert-hunk)
	("C-x C-g C-g" . git-gutter-mode)
	("C-x C-g g" . git-gutter-mode)
	("C-x C-g n" . git-gutter:next-hunk)
	("C-x C-g p" . git-gutter:previous-hunk)
	)
#+END_SRC

* Shells

** Windows powershell

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
		(use-package powershell
			:ensure t)
)
(put 'upcase-region 'disabled nil)
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
					'(lambda () (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
(setq eshell-cmpl-dir-ignore "\`\\(CVS\\)/\\'") ; in order to complete `..` to `../`
(defun tl/eshell ()										; http://emacs.stackexchange.com/a/28603/12336
  (interactive)
  (eshell t))
(global-set-key (kbd "<f7> e") 'tl/eshell)
 #+END_SRC

* bbdb

http://sachachua.com/notebook/emacs/bbdb-config.el

#+BEGIN_SRC emacs-lisp
  (use-package bbdb
    :ensure t
    :config (progn
              (bbdb-initialize)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-message)
                                          ;(add-hook 'message-setup-hook 'bbdb-define-all-aliases)

              (setq bbdb-file "~/Dropbox/bbdb"
                    bbdb-auto-revert t
                    bbdb-check-auto-save-file t
                    bbdb-expand-mail-aliases t
                    bbdb-phone-style nil
                    ;; bbdb-pop-up-window-size 10
                    bbdb-pop-up-target-lines 1 ; The window should be as small as possible
                    bbdb-use-pop-up nil        ; Show pup-up?

                                          ;bbdb/news-auto-create-p t
                    bbdb-complete-name-allow-cycling t
                    bbdb-complete-mail-allow-cycling t
                    bbdb-complete-name-full-completion t
                    bbdb-completion-type 'primary-or-name
                                          ;bbdb-use-pop-up nil

                    bbdb-offer-save 1  ; Always save
                    bbdb-electric-p t)
              ))

  (use-package bbdb-vcard
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-bbdb
    :ensure t)
  (global-set-key (kbd "<f7> a") 'helm-bbdb)
#+END_SRC

* tramp

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (if (eq system-type 'windows-nt) 
      (setq tramp-default-method "plink")
    (setq tramp-default-method "ssh"))
  (setq tramp-default-user "lichte")
#+END_SRC

* hydra

** hydra: begin
#+BEGIN_SRC emacs-lisp
	(use-package hydra
		:ensure t
		:config

#+END_SRC

** hydra-git-gutter

#+BEGIN_SRC emacs-lisp

		;; inspired by https://github.com/abo-abo/hydra/wiki/Git-gutter
		(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
																					:hint nil)
			"
	Git gutter:
		_j_: next hunk        _s_tage hunk     _q_uit
		_k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
		^ ^                   _p_opup hunk
		_h_: first hunk
		_l_: last hunk        set start _R_evision
	"
			("j" git-gutter:next-hunk)
			("k" git-gutter:previous-hunk)
			("h" (progn (goto-char (point-min))
									(git-gutter:next-hunk 1)))
			("l" (progn (goto-char (point-min))
									(git-gutter:previous-hunk 1)))
			("s" git-gutter:stage-hunk)
			("r" git-gutter:revert-hunk)
			("p" git-gutter:popup-hunk)
			("R" git-gutter:set-start-revision)
			("q" nil :color blue)
			("Q" (progn (git-gutter-mode -1)
									;; git-gutter-fringe doesn't seem to
									;; clear the markup right away
									(sit-for 0.1)
									(git-gutter:clear))
			 :color blue))
		(global-set-key (kbd "<f8> g") 'hydra-git-gutter/body)

		;; inspired by https://github.com/abo-abo/hydra/wiki/Flycheck
		(defhydra hydra-flycheck
			(:pre (progn (setq hydra-lv t) (flycheck-list-errors))
						:post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
						:hint nil)
			"Errors"
			("f"  flycheck-error-list-set-filter                            "Filter")
			("j"  flycheck-next-error                                       "Next")
			("k"  flycheck-previous-error                                   "Previous")
			("gg" flycheck-first-error                                      "First")
			("G"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
			("q"  nil))
      (global-set-key (kbd "<f4>") nil)
		(global-set-key (kbd "<f4> f") 'hydra-flycheck/body)
#+END_SRC

** hydra-next-error

#+BEGIN_SRC emacs-lisp
		;; inspired by https://github.com/abo-abo/hydra/wiki/Compilation
		(defhydra hydra-next-error
			(global-map "C-x")
			"
	Compilation errors:
	_j_: next error        _h_: first error    _q_uit
	_k_: previous error    _l_: last error
	"
			("`" next-error     nil)
			("j" next-error     nil :bind nil)
			("k" previous-error nil :bind nil)
			("h" first-error    nil :bind nil)
			("l" (condition-case err
							 (while t
								 (next-error))
						 (user-error nil))
			 nil :bind nil)
			("q" nil            nil :color blue))
		(global-set-key (kbd "<f4> e") 'hydra-next-error/body)
#+END_SRC

** hydra-multiple-cursors

#+BEGIN_SRC emacs-lisp
		;; inspired by https://github.com/abo-abo/hydra/wiki/multiple-cursors
		(defhydra hydra-multiple-cursors (:hint nil :idle 0.5)
			"
			 ^Up^            ^Down^        ^Other^
	----------------------------------------------
	[_p_]   Next    [_n_]   Next    [_l_] Edit lines
	[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
	[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
	^ ^             ^ ^             [_q_] Quit
	"
		("l" mc/edit-lines :exit t)
		("a" mc/mark-all-like-this :exit t)
		("n" mc/mark-next-like-this)
		("N" mc/skip-to-next-like-this)
		("M-n" mc/unmark-next-like-this)
		("p" mc/mark-previous-like-this)
		("P" mc/skip-to-previous-like-this)
		("M-p" mc/unmark-previous-like-this)
		("r" mc/mark-all-in-region-regexp :exit t)
		("q" nil))
		(global-set-key (kbd "C-<") 'hydra-multiple-cursors/body)
  #+END_SRC
  
** TODO hydra-highlight-changes

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-changes
			(:body-pre (highlight-changes-visible-mode +1)
      :hint nil
      :idle 0.5)
			"
	Highlight changes:
	  _<up>_: next change       _q_uit
	_<down>_: previous change   _Q_uit and turn off highlighting 
	"
			("<down>" highlight-changes-next-change)
			("<up>" highlight-changes-previous-change)
			("<right>" highlight-changes-next-change)
			("<left>" highlight-changes-previous-change)
			("j" highlight-changes-next-change)
			("k" highlight-changes-previous-change)
			("n" highlight-changes-next-change)
			("p" highlight-changes-previous-change)
			("Q" (highlight-changes-visible-mode -1) :color blue)
			("q" nil :color blue))
		(global-set-key (kbd "<f8> c") 'hydra-highlight-changes/body)
#+END_SRC

** TODO hydra-window

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-window
		(:hint nil
					 :idle 0.5)
	"
		Window actions:
						 ^_<up>_^                 |                           _z_: window undo
							^^↑^^                   |split _h_orizontally         _Z_: window redo
		 _<left>_ ←   → _<right>_         |                        _<f2>_: new frame
							^^↓^^                  ──────────────────               _q_uit
						^_<down>_^               split _v_ertically                  
	"
	("<down>" windmove-down :exit t)
	("<up>" windmove-up :exit t)
	("<right>" windmove-right :exit t)
	("<left>" windmove-left :exit t)
	("<f2>" make-frame :exit t)
	("v" split-window-vertically :exit t)
	("h" split-window-horizontally :exit t)
	("z" winner-undo)
	("Z" winner-redo)
	("q" nil :color blue))
	(global-set-key (kbd "<f2>") 'hydra-window/body)
#+END_SRC

** TODO hydra-highlight-symbol

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-symbol
			(:pre (highlight-symbol-at-point) 
      :hint nil
			 :idle 0.5)
			"
	Highlight symbol:
		_<up>_: previous occurrence    _r_: replace occurrences     _q_uit 
	_<down>_: next occurrence        
	"
			("<down>" highlight-symbol-next)
			("<up>" highlight-symbol-prev)
			("<right>" highlight-symbol-next)
			("<left>" highlight-symbol-prev)
			("j" highlight-symbol-next)
			("k" highlight-symbol-prev)
			("n" highlight-symbol-next)
			("p" highlight-symbol-prev)
			("c" highlight-symbol-count)
			("r" highlight-symbol-query-replace)
			("l" highlight-symbol-list-all)
			("q" highlight-symbol-remove-all :color blue))
		(global-set-key (kbd "<f8> s") 'hydra-highlight-symbol/body)
#+END_SRC

** hydra: end           
  #+BEGIN_SRC emacs-lisp
		)                   
#+END_SRC
